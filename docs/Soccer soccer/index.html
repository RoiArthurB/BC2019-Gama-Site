<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Soccer Game · GAMA-Platform</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="GAMA"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Soccer Game · GAMA-Platform"/><meta property="og:type" content="website"/><meta property="og:url" content="https://roiarthurb.github.io/BC2019-Gama-Site/"/><meta property="og:description" content="GAMA"/><meta property="og:image" content="https://roiarthurb.github.io/BC2019-Gama-Site//resources/images/general/GamaPlatform.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://roiarthurb.github.io/BC2019-Gama-Site//resources/images/general/GamaPlatform.png"/><link rel="shortcut icon" href="/BC2019-Gama-Site//img/gama-logo.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js" async=""></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js" async=""></script><script type="text/javascript" src="/BC2019-Gama-Site/js/code-block-buttons.js" async=""></script><link rel="stylesheet" href="/BC2019-Gama-Site/css/main.css"/><script src="/BC2019-Gama-Site/js/codetabs.js"></script></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/BC2019-Gama-Site/"><img class="logo" src="/BC2019-Gama-Site//img/gama-logo.png" alt="GAMA-Platform"/><h2 class="headerTitleWithLogo">GAMA-Platform</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/BC2019-Gama-Site/docs/Home" target="_self">Documentation</a></li><li class=""><a href="/BC2019-Gama-Site/docs/Tutorials" target="_self">Tutorials</a></li><li class=""><a href="/BC2019-Gama-Site/help" target="_self">Download</a></li><li class=""><a href="/BC2019-Gama-Site/help" target="_self">Contribute</a></li><li class=""><a target="_self">Blog</a></li><li class=""><a target="_self"></a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Soccer Game</h1></header><article><div><span><p><em>Author : Julien</em></p>
<p>This model shows how can we make an easy simulation of collective games, such as soccer.
Each player have an offensive and a defensive position, and a behavior associated. Each player of the defensive team can either search to catch the ball or mark an other player (offensive player) according to his defensive position.
Each player of the offensive team can either run to its offensive place (when he does not have the ball), run with the balloon / pass the ball / try to score a goal (when he has the ball). By changing the different parameters, you can see the concequences in real time.</p>
<p>Code of the model :</p>
<pre><code class="hljs">
model soccer

global {
    geometry shape &lt;- rectangle(120#m,90#m);
    float red_players_speed &lt;- 1.0;
    float blue_players_speed &lt;- 1.0;
    float red_size_play_area &lt;- 30.0 min:1.0 max:100.0;
    float blue_size_play_area &lt;- 30.0 min: 1.0 max:100.0;
    float previous_red_size_play_area &lt;- red_size_play_area; <span class="hljs-comment">// just to check if the parameter value has been changed</span>
    float previous_blue_size_play_area &lt;- blue_size_play_area; <span class="hljs-comment">// just to check if the parameter value has been changed</span>
    float red_collective_play &lt;- 0.5 min:0.0 max:1.0;
    float blue_collective_play &lt;- 0.5 min:0.0 max:1.0;
    float red_recuperation_ability &lt;- 0.5 min:0.0 max:1.0;
    float blue_recuperation_ability &lt;- 0.5 min:0.0 max:1.0;
    
    int red_score &lt;- 0;
    int red_possession &lt;- 0;
    int nb_red_pass &lt;- 0;
    int nb_red_pass_succeed &lt;- 0;
    int nb_red_interception &lt;- 0;
    int blue_score &lt;- 0;
    int blue_possession &lt;- 0;
    int nb_blue_pass &lt;- 0;
    int nb_blue_pass_succeed &lt;- 0;
    int nb_blue_interception &lt;- 0;
    
    bool show_status &lt;- false;
    bool show_area &lt;- false;
    bool show_marked_player &lt;- false;
    bool show_ball_indicator &lt;- false;
    
    bool play_with_offside &lt;- true;
    
    list&lt;point&gt; bluePlayerPosition &lt;- [{8,10}, {8,80}, {10,30}, {10,60},
        {30,25}, {28,45}, {30,65},
        {50,25}, {50,65}, {55,45}
    ];
    
    list&lt;point&gt; redPlayerPosition &lt;- [{120-8,10}, {120-8,80}, {120-10,30}, {120-10,60},
        {120-30,25}, {120-28,45}, {120-30,65},
        {120-50,25}, {120-50,65}, {120-55,45}
    ];
    
    ball ball_agent;
    player closest_red_player_from_the_ball;
    player closest_blue_player_from_the_ball;
    player called_player;
    string team_possession &lt;- <span class="hljs-string">""</span>;
    float blue_offside_pos &lt;- 120.0;
    float red_offside_pos &lt;- 0.0;
    
    init {
        loop pos over:redPlayerPosition {
            create player with:[team::<span class="hljs-string">"red"</span>, location::pos];
        }
        loop pos over:bluePlayerPosition {
            create player with:[team::<span class="hljs-string">"blue"</span>, location::pos];
        }
        create ball with:[location::location] returns:ball_agt;
        ball_agent&lt;-ball_agt at 0;
        create goal with:[location::{0,location.y}, team::<span class="hljs-string">"blue"</span>];
        create goal with:[location::{120,location.y}, team::<span class="hljs-string">"red"</span>];
    }
    
    reflex update {
        float shortest_distance &lt;- 100.0;
        float offside_pos &lt;- 0.0;
        ask player where (each.team = <span class="hljs-string">"red"</span>) {
            if (distance_to_ball &lt; shortest_distance and inactivity_time=0) {
                closest_red_player_from_the_ball &lt;- self;
                shortest_distance &lt;- distance_to_ball;
            }
            if (location.x &gt; offside_pos) {
                offside_pos &lt;- location.x;
                red_offside_pos &lt;- offside_pos;
            }
        }
        if (not play_with_offside) {
            red_offside_pos &lt;- 120.0;
        }
        
        shortest_distance &lt;- 100.0;
        offside_pos &lt;- 100.0;
        ask player where (each.team = <span class="hljs-string">"blue"</span>) {
            if (distance_to_ball &lt; shortest_distance and inactivity_time=0) {
                closest_blue_player_from_the_ball &lt;- self;
                shortest_distance &lt;- distance_to_ball;
            }
            if (location.x &lt; offside_pos) {
                offside_pos &lt;- location.x;
                blue_offside_pos &lt;- offside_pos;
            }
        }
        if (not play_with_offside) {
            blue_offside_pos &lt;- 0.0;
        }
        
        if (previous_red_size_play_area != red_size_play_area) {
            ask area where (each.team = <span class="hljs-string">"red"</span>) {
                do update_size;
            }
            previous_red_size_play_area &lt;- red_size_play_area;
        }
        if (previous_blue_size_play_area != blue_size_play_area) {
            ask area where (each.team = <span class="hljs-string">"blue"</span>) {
                do update_size;
            }
            previous_blue_size_play_area &lt;- blue_size_play_area;
        }
        if (team_possession = <span class="hljs-string">"blue"</span>) {
            blue_possession &lt;- blue_possession + 1;
        }
        if (team_possession = <span class="hljs-string">"red"</span>) {
            red_possession &lt;- red_possession + 1;
        }
    }
    
    action reinit_phase {
        ask player {
            location &lt;- init_pos;
            previous_pos &lt;- init_pos;
        }
        ball_agent.location &lt;- location;
        ball_agent.destination &lt;- location;
        ball_agent.speed &lt;- 0.0;
    }
}

species player skills:[moving] {
    string team &lt;- <span class="hljs-string">""</span>; <span class="hljs-comment">// value : "blue" (left side) or "red" (right side)</span>
    bool possess_ball &lt;- false;
    int inactivity_time &lt;- 0 update:(inactivity_time&lt;=0) ? 0 : inactivity_time-1;
    int seed &lt;- rnd(100);
    point init_pos;
    point previous_pos;
    
    <span class="hljs-comment">// strategy</span>
    area defensive_pos;
    area offensive_pos;
    player marked_player;
    float collective_mark &lt;- 0.5 update:(team=<span class="hljs-string">"red"</span>) ? red_collective_play : blue_collective_play;
    float recuperation_mark &lt;- 0.5 update:(team=<span class="hljs-string">"red"</span>) ? red_recuperation_ability : blue_recuperation_ability;
    
    string status &lt;- <span class="hljs-string">""</span>;
    
    <span class="hljs-comment">// moving attributes</span>
    float running_speed_without_ball &lt;- 0.8 update:(team=<span class="hljs-string">"red"</span>) ? red_players_speed*0.8 : blue_players_speed*0.8;
    float running_speed_with_ball &lt;- 0.6 update:(team=<span class="hljs-string">"red"</span>) ? red_players_speed*0.5 : blue_players_speed*0.5;
    float speed &lt;- 0.0 max:1.2;
    point velocity &lt;- {0,0};
    
    float distance_to_closest_ennemy &lt;- 100.0;
    float distance_to_ennemy_goal &lt;- 100.0 update:self distance_to ( (goal where (each.team != team)) at 0);
    float distance_to_ball &lt;- 100.0 update:self distance_to ball_agent;
    
    init {
        init_pos &lt;- location;
        previous_pos &lt;- location;
        create area with:[location::init_pos, team::self.team, position::init_pos] returns:def_pos;
        defensive_pos &lt;- def_pos at 0;
        point offensivePos &lt;- {(team=<span class="hljs-string">"red"</span>) ? init_pos.x-60 : init_pos.x+60,init_pos.y};
        create area with:[location::offensivePos, team::self.team, position::offensivePos] returns:off_pos;
        offensive_pos &lt;- off_pos at 0;
    }
    
    reflex update_status {
        distance_to_closest_ennemy &lt;- 100.0;
        loop pl over:player where (each.team != team) {
            float distance_to_ennemy &lt;- self distance_to pl;
            if (distance_to_ennemy &lt; distance_to_closest_ennemy) {
                distance_to_closest_ennemy &lt;- distance_to_ennemy;
            }
        }
    }
    
    reflex defensive_behavior when:team_possession != team {
        <span class="hljs-comment">// the ball is not possessed by the team.</span>
        do apply_inertia;
        if (self = closest_red_player_from_the_ball or self = closest_blue_player_from_the_ball) {
            do run_to_ball;
        }
        else {
            do defensive_move;
        }
    }
    
    reflex offensive_behavior when:team_possession = team {
        do apply_inertia;
        if (possess_ball) {
            do run_with_ball;
            if (distance_to_ennemy_goal &lt; 30 and flip(1/(distance_to_ennemy_goal*distance_to_ennemy_goal/10+1))) {
                <span class="hljs-comment">// shoot !</span>
                do kick_ball_to_goal;
            }
            else {
                <span class="hljs-comment">// pass !</span>
                if (distance_to_closest_ennemy &lt; 5) {
                    if (flip(collective_mark)) {
                        do pass_the_ball;
                    }
                }
                else if flip(collective_mark/50) {
                    do pass_the_ball;
                }
            }
        }
        else if (ball_agent.belong_to_team = <span class="hljs-string">""</span> and
            (self = closest_red_player_from_the_ball or self = closest_blue_player_from_the_ball
            or self = called_player)
        ) {
            do run_to_ball;
        }
        else {
            do offensive_move;
        }
    }
    
    reflex choose_player_to_mark when:(cycle mod 20=seed or cycle=0) {
        if ( not empty(player where(each.offensive_pos intersects defensive_pos)) ) {
            marked_player &lt;- 1 among (player where((each.offensive_pos intersects defensive_pos) and (each.team != team))) at 0;
        }
    }
    
    action apply_inertia {
        point prev_pos &lt;- location;
        point inertia_vect &lt;- {(location.x-previous_pos.x)*0.8,(location.y-previous_pos.y)*0.8};
        float max_inertia &lt;- running_speed_without_ball;
        if (norm(inertia_vect) &gt; max_inertia) {
            float inertia_x &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));
            float inertia_y &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));
            inertia_x &lt;- (inertia_vect.x &lt; 0) ? -inertia_x : inertia_x;
            inertia_y &lt;- (inertia_vect.y &lt; 0) ? -inertia_y : inertia_y;
            inertia_vect &lt;- {inertia_x,inertia_y};
        }
        location &lt;- location + inertia_vect;
        previous_pos &lt;- prev_pos;
    }
    
    action run_to_ball {
        point targetPos;
        if (ball_agent.ball_direction intersects circle(1)) {
            targetPos &lt;- ball_agent.location;
        }
        else {
            targetPos &lt;- (ball_agent.ball_direction closest_points_with self) at 0;
        }
        do goto with:[target::targetPos, speed::running_speed_without_ball];
        
        status &lt;- <span class="hljs-string">"run to the ball"</span>;
        
        <span class="hljs-comment">// if close enough, catch the ball</span>
        if (location distance_to ball_agent.location &lt; 1.5#m) {
            if (self = called_player) {
                do take_ball;
            }
            else if (ball_agent.belong_to_team = <span class="hljs-string">""</span>) {
                if flip(1/(ball_agent.speed*recuperation_mark+1)) {
                    do take_ball;
                }
            }
            else {
                if (team_possession = team) {
                    <span class="hljs-comment">// result of a long pass for instance</span>
                    if (flip(recuperation_mark*1.5)) {
                        do take_ball;
                    }
                }
                else {
                    <span class="hljs-comment">// interception of the ball</span>
                    if (flip(recuperation_mark*0.8)) {
                        do take_ball;
                    }
                }
            }
        }
    }
    
    action run_with_ball {
        status &lt;- <span class="hljs-string">"run with the ball"</span>;
        point goal_pos;
        ask goal {
            if (self.team != myself.team) {
                goal_pos &lt;- location;
            }
        }
        do goto with:[target::goal_pos, speed::running_speed_with_ball];
        ball_agent.location &lt;- location;
    }
    
    action offensive_move {
        <span class="hljs-comment">// try to reach an offensive postion</span>
        point target_location;
        geometry possible_pos &lt;- (team=<span class="hljs-string">"red"</span>) ? world inter (rectangle({blue_offside_pos,0},{120,90}))
        : world inter (rectangle({0,0},{red_offside_pos,90}));
        
        
        <span class="hljs-comment">// check if the player is in the field</span>
        if (location.y &lt; 0) {
            target_location &lt;- {location.x,90};
        }
        else if (location.y &gt; 90) {
            target_location &lt;- {location.x,0};
        }
        <span class="hljs-comment">// check if the player is in offside position</span>
        else if ( (location.x &gt; red_offside_pos and team = <span class="hljs-string">"blue"</span>) or (location.x &lt; blue_offside_pos and team = <span class="hljs-string">"red"</span>)) {
            target_location &lt;- (team=<span class="hljs-string">"red"</span>) ? {120,location.y} : {0,location.y};
            status &lt;- <span class="hljs-string">"run to a non offside position"</span>;
        }
        else {
            status &lt;- <span class="hljs-string">"run to a offensive place"</span>;
            if (not (possible_pos intersects offensive_pos)) {
                target_location &lt;- (team=<span class="hljs-string">"red"</span>) ? {blue_offside_pos,location.y} : {red_offside_pos,location.y};
            }
            else
            {
                target_location &lt;- any_location_in(offensive_pos inter possible_pos);
            }
        }
        do goto target:target_location speed:running_speed_without_ball;
    }
    
    action defensive_move {
        <span class="hljs-comment">// try to mark an ennemy player</span>
        status &lt;- <span class="hljs-string">"mark ennemy player"</span>;
        if (not (marked_player = <span class="hljs-literal">nil</span>)) {
            do goto with:[target::marked_player.location+((team=<span class="hljs-string">"red"</span>)?{2+rnd(5.0),rnd(2.0)-1} : {-2-rnd(5.0),rnd(2.0)-1}), speed::running_speed_without_ball];
        }
    }
    
    action kick_ball_to_goal {
        do loose_ball;
        ask ball_agent {
            do shooted speed_atr:4.0 target_position:((goal where (each.team != myself.team)) at 0).location;
        }
        inactivity_time &lt;- 20;
    }
    
    action pass_the_ball {
        float wisest_choice_mark &lt;- -100.0;
        player wisest_target;
        ask player  where(each.team = team and each != self and (self distance_to each &gt; 15)) {
            int number_of_ennemies_on_range &lt;- length(player at_distance 5 where (each.team != myself.team));
            float wise_choice_mark &lt;- 100-distance_to_ball+number_of_ennemies_on_range*10-2*distance_to_ennemy_goal;
            if (wise_choice_mark &gt; wisest_choice_mark) {
                wisest_target &lt;- self;
                wisest_choice_mark &lt;- wise_choice_mark;
            }
        }
        if (wisest_choice_mark &gt; -100.0) {
            <span class="hljs-comment">// a target has been found</span>
            do loose_ball;
            ask ball_agent {
                do shooted target_position:wisest_target.location speed_atr:wisest_target.distance_to_ball/8;
            }
            called_player &lt;- wisest_target;
            inactivity_time &lt;- 20;
            if (team = <span class="hljs-string">"red"</span>) {nb_red_pass &lt;- nb_red_pass+1;}
            else {nb_blue_pass &lt;- nb_blue_pass+1;}
        }
    }
    
    action take_ball {
        if (ball_agent.belong_to_team != <span class="hljs-string">""</span> and ball_agent.belong_to_team != team) {
            ask ball_agent.belong_to_player {
                do loose_ball;
            }
        }
        team_possession &lt;- team;
        possess_ball &lt;- true;
        ball_agent.belong_to_team &lt;- team;
        ball_agent.belong_to_player &lt;- self;
        ball_agent.speed &lt;- 0.0;
        if (self = called_player) {
            if (team = <span class="hljs-string">"red"</span>) {nb_red_pass_succeed &lt;- nb_red_pass_succeed+1;}
            else {nb_blue_pass_succeed &lt;- nb_blue_pass_succeed+1;}
        }
        else {
            if (team = <span class="hljs-string">"red"</span>) {nb_red_interception &lt;- nb_red_interception+1;}
            else {nb_blue_interception &lt;- nb_blue_interception+1;}
        }
        called_player &lt;- <span class="hljs-literal">nil</span>;
    }
    
    action loose_ball {
        possess_ball &lt;- false;
        ball_agent.belong_to_team &lt;- <span class="hljs-string">""</span>;
    }
    
    aspect base {
        draw circle(1) color:(team=<span class="hljs-string">"red"</span>) ? #red : #blue;
        if (show_status) {
            draw string(status);
            if (marked_player != <span class="hljs-literal">nil</span>) {
                draw polyline([location,marked_player.location]);
            }
        }
        if (marked_player != <span class="hljs-literal">nil</span> and show_marked_player) {
            draw polyline([location,marked_player.location]) end_arrow:1 color:#chartreuse;
        }
    }
}

species area {
    string team &lt;- <span class="hljs-string">""</span>;
    point position;
    
    init {
        shape &lt;- ((team=<span class="hljs-string">"red"</span>) ? square(red_size_play_area) : square(blue_size_play_area)) inter world;
    }
    
    action update_size {
        location &lt;- position;
        shape &lt;- ((team=<span class="hljs-string">"red"</span>) ? square(red_size_play_area) : square(blue_size_play_area)) inter world;
    }
    
    aspect base {
        if (show_area) {
            draw shape color:rgb(128,128,128,50) border:(team=<span class="hljs-string">"red"</span>) ? rgb(256,0.0,0.0,100) : rgb(0.0,0.0,256.0,100);
        }
    }
}

species ball skills:[moving]{
    string belong_to_team &lt;- <span class="hljs-string">""</span>;
    player belong_to_player;
    float speed &lt;- 0.0 update:speed*0.9;
    list&lt;point&gt; nextPlace;
    geometry ball_direction;
    reflex update {
        float future_speed &lt;- speed;
        point tmpPos&lt;-location;
        loop i from:0 to:10 {
            tmpPos &lt;- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};
            future_speed &lt;- future_speed*0.9;
        }
        ball_direction &lt;- line([location,tmpPos]);
        if ((location.x+cos(heading)*speed) &gt; 120) {
            blue_score &lt;- blue_score + 1;
            ask world {
                do reinit_phase;
            }
        }
        if ((location.x+cos(heading)*speed) &lt; 0) {
            red_score &lt;- red_score + 1;
            ask world {
                do reinit_phase;
            }
        }
        do wander amplitude:1;
    }
    action shooted (point target_position, float speed_atr) {
        speed &lt;- speed_atr;
        do goto target:target_position;
    }
    aspect base {
        draw circle(0.5) color:#white border:#black;
        if (show_ball_indicator) {
            draw ball_direction end_arrow:1 color:#chartreuse;
            if (team_possession=<span class="hljs-string">"red"</span>) {
                draw circle(0.5) color:#darkred border:#black;
            }
            else if (team_possession=<span class="hljs-string">"blue"</span>) {
                draw circle(0.5) color:#darkblue border:#black;
            }
        }
    }
}

species goal {
    string team &lt;- <span class="hljs-string">""</span>;
    aspect base {
        draw rectangle(0.1,7.32) color:#black;
    }
}


experiment match type:gui {
    parameter <span class="hljs-string">"blue running speed"</span> var:blue_players_speed category:<span class="hljs-string">"Blue Team"</span>;
    parameter <span class="hljs-string">"red running speed"</span> var:red_players_speed category:<span class="hljs-string">"Red Team"</span>;
    <span class="hljs-comment">// speed of players when they run. Note that a player which have the ball will run at 50% of his max capacity, and he will run at 80% of his max capacity if he does not have the ball.</span>
    
    parameter <span class="hljs-string">"blue collective play"</span> var:blue_collective_play category:<span class="hljs-string">"Blue Team"</span>;
    parameter <span class="hljs-string">"red collective play"</span> var:red_collective_play category:<span class="hljs-string">"Red Team"</span>;
    <span class="hljs-comment">// propention of giving the ball to an other player of the team. If the value is 0, the player will never pass the ball.</span>
    
    parameter <span class="hljs-string">"blue recuperation ability"</span> var:blue_recuperation_ability category:<span class="hljs-string">"Blue Team"</span>;
    parameter <span class="hljs-string">"red recuperation ability"</span> var:red_recuperation_ability category:<span class="hljs-string">"Red Team"</span>;
    <span class="hljs-comment">// ability to catch the ball when no player has it and when a player of the other team has it. 1 for very good hability, 0 for very poor hability.</span>
    
    parameter <span class="hljs-string">"blue play area size"</span> var:blue_size_play_area category:<span class="hljs-string">"Blue Team"</span>;
    parameter <span class="hljs-string">"red play area size"</span> var:red_size_play_area category:<span class="hljs-string">"Red Team"</span>;
    <span class="hljs-comment">// change the size of the area of each player. The bigger this area is, the less players will maintains their position.</span>
    
    parameter <span class="hljs-string">"display status"</span> var:show_status category:<span class="hljs-string">"Display"</span>;
    <span class="hljs-comment">// displays or not the current status of the player (his intentions)</span>
    
    parameter <span class="hljs-string">"display play area"</span> var:show_area category:<span class="hljs-string">"Display"</span>;
    <span class="hljs-comment">// displays or not the offensive and defensive area of each player. The bigger this area is, the less players will maintains their position.</span>
    
    parameter <span class="hljs-string">"display marked player"</span> var:show_marked_player category:<span class="hljs-string">"Display"</span>;
    <span class="hljs-comment">// displays or not an arrow between the player that are marked each other.</span>
    
    parameter <span class="hljs-string">"display ball indicators"</span> var:show_ball_indicator category:<span class="hljs-string">"Display"</span>;
    <span class="hljs-comment">// changes the color of the ball if the ball is possessed by the blue or the red team. Display also the direction of the ball when it has been shooted.</span>
    
    parameter <span class="hljs-string">"play with offside position"</span> var:play_with_offside category:<span class="hljs-string">"Rules"</span>;
    <span class="hljs-comment">// play with or without the "offside" rule.</span>
    
    output {
        display <span class="hljs-string">"soccer_field"</span> {
            <span class="hljs-comment">// display the field.</span>
            image <span class="hljs-string">"../images/soccer_field.png"</span>;
            species player aspect:base;
            species ball aspect:base;
            species goal aspect:base;
            species area aspect:base;
            graphics <span class="hljs-string">"score_display"</span> {
                draw <span class="hljs-string">"Blue side - "</span>+string(blue_score) color:#blue at: {10,5} font: font(<span class="hljs-string">"Helvetica"</span>, 18 * #zoom, #bold) perspective:true;
                draw string(red_score)+<span class="hljs-string">" - Red side"</span> color:#red at: {100,5} font: font(<span class="hljs-string">"Helvetica"</span>, 18 * #zoom, #bold) perspective:true;
                if (show_status) {
                    draw line([{red_offside_pos,0},{red_offside_pos,90}]) color:#red;
                    draw line([{blue_offside_pos,0},{blue_offside_pos,90}]) color:#blue;
                }
            }
        }
        display <span class="hljs-string">"match_stats"</span> {
            <span class="hljs-comment">// display some statistics about the game</span>
            chart <span class="hljs-string">"ball_possession"</span> type:pie position:{0,0} size:{0.5,0.5} {
                data <span class="hljs-string">"Red possession"</span> value:red_possession color:#red;
                data <span class="hljs-string">"Blue possession"</span> value:blue_possession color:#blue;
            }
            chart <span class="hljs-string">"red pass"</span> type:pie position:{0,0.5} size:{0.5,0.5} {
                <span class="hljs-comment">// note that a pass is said "successful" if the player that has the ball was the player called initially. A "failed pass" does not necessary means that the team have lost the ball.</span>
                    data <span class="hljs-string">"Red pass succeed"</span> value:(nb_red_pass = 0) ? 0 : float(nb_red_pass_succeed)/float(nb_red_pass) color:#red;
                    data <span class="hljs-string">"Red pass failed"</span> value:(nb_red_pass = 0) ? 0 : 1-float(nb_red_pass_succeed)/float(nb_red_pass) color:#darkred;
            }
            chart <span class="hljs-string">"blue pass"</span> type:pie position:{0.5,0.5} size:{0.5,0.5} {
                <span class="hljs-comment">// note that a pass is said "successful" if the player that has the ball was the player called initially. A "failed pass" does not necessary means that the team have lost the ball.</span>
                data <span class="hljs-string">"Blue pass succeed"</span> value:(nb_blue_pass = 0) ? 0 : float(nb_blue_pass_succeed)/float(nb_blue_pass) color:#blue;
                data <span class="hljs-string">"Blue pass failed"</span> value:(nb_blue_pass = 0) ? 0 : 1-float(nb_blue_pass_succeed)/float(nb_blue_pass) color:#darkblue;
            }
            chart <span class="hljs-string">"number pass"</span> type:series position:{0.5,0} size:{0.5,0.5} {
                data <span class="hljs-string">"Number pass red"</span> value:nb_red_pass color:#red;
                data <span class="hljs-string">"Number pass blue"</span> value:nb_blue_pass color:#blue;
            }
        }
    }
}
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/BC2019-Gama-Site/" class="nav-home"><img src="/BC2019-Gama-Site//img/gama-logo.png" alt="GAMA-Platform" width="66" height="58"/></a><div><h5>Networks</h5><a href="https://www.youtube.com/channel/UCWJ1kWGDDI-9u2f2uD0gcaQ" target="_blank"><i class="fab fa-youtube"></i> Youtube</a><a href="https://www.linkedin.com/company/gama-platform" target="_blank"><i class="fab fa-linkedin"></i> LinkedIn</a><a href="https://twitter.com/gamaplatform" target="_blank"><i class="fab fa-twitter"></i> Twitter</a><a href="https://www.facebook.com/GamaPlatform/" target="_blank"><i class="fab fa-facebook"></i> Facebook</a></div><div><h5>Mailing list</h5><a href="https://groups.google.com/forum/#!forum/gama-platform" target="_blank"><i class="fas fa-envelope"></i> For Users<br/>gama-platform@googlegroups.com</a><a href="https://groups.google.com/forum/#!forum/gama-dev" target="_blank"><i class="fas fa-envelope"></i> For Developers<br/>gama-dev@googlegroups.com</a></div><div><h5>Ecosystem</h5><a href="https://github.com/gama-platform/gama"><i class="fab fa-github"></i> GitHub Gama</a><a href="https://github.com/gama-platform/gama.experimental"><i class="fas fa-puzzle-piece"></i> Gama Experimental Plugins</a><a href="https://github.com/gama-platform/gama.models.experimental"><i class="fas fa-scroll"></i> Gama Experimental Models</a></div></section><section class="copyright">Copyright © 2019 GAMA-Platform</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0f9f28b9ab9efae89810921a351753b5',
                indexName: 'github',
                inputSelector: '#search_input_react'
              });
            </script></body></html>