<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Tutorials/LearnGAMLStepByStep/OptimizingModels/OptimizingModels · GAMA-Platform</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="GAMA, modeling made easy"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Tutorials/LearnGAMLStepByStep/OptimizingModels/OptimizingModels · GAMA-Platform"/><meta property="og:type" content="website"/><meta property="og:url" content="https://roiarthurb.github.io/BC2019-Gama-Site/"/><meta property="og:description" content="GAMA, modeling made easy"/><meta property="og:image" content="https://roiarthurb.github.io/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://roiarthurb.github.io/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><link rel="shortcut icon" href="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/atom.xml" title="GAMA-Platform Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/feed.xml" title="GAMA-Platform Blog RSS Feed"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/BC2019-Gama-Site/js/code-block-buttons.js"></script><link rel="stylesheet" href="/BC2019-Gama-Site/css/main.css"/><script src="/BC2019-Gama-Site/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/BC2019-Gama-Site/"><img class="logo" src="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png" alt="GAMA-Platform"/><h2 class="headerTitleWithLogo">GAMA-Platform</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a target="_self">Index</a></li><li class=""><a href="/BC2019-Gama-Site/docs/Home" target="_self">Docs</a></li><li class=""><a href="/BC2019-Gama-Site/help" target="_self">Help</a></li><li class=""><a href="/BC2019-Gama-Site/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Tutorials/LearnGAMLStepByStep/OptimizingModels/OptimizingModels</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="optimizing-models"></a><a href="#optimizing-models" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optimizing Models</h1>
<p>This page aims at presenting some tips to optimize the memory footprint or the execution time of a model in GAMA.</p>
<p><em>Note:  since GAMA 1.6.1, some optimizations have become obsolete because they have been included in the compiler. They have, then, been removed from this page. For instance, writing 'rgb(0,0,0)' is now compiled directly as '#black'.</em></p>
<h2><a class="anchor" aria-hidden="true" id="table-of-contents"></a><a href="#table-of-contents" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Table of contents</h2>
<ul>
<li><a href="#machinetime">machine_time</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#grid">Grid</a>
<ul>
<li><a href="#optimization-facets">Optimization Facets</a>
<ul>
<li><a href="#useregularagents">use_regular_agents</a></li>
<li><a href="#useindividualshapes">use_individual_shapes</a></li>
</ul></li>
</ul></li>
<li><a href="#operators">Operators</a>
<ul>
<li><a href="#list-operators">List operators</a>
<ul>
<li><a href="#firstwith">first_with</a></li>
<li><a href="#where--count">where / count</a></li>
</ul></li>
<li><a href="#spatial-operators">Spatial operators</a>
<ul>
<li><a href="#container-of-agents-in-closestto-atdistance-overlapping-inside">container of agents in closest_to, at_distance, overlapping, inside</a></li>
<li><a href="#accelerate--with-a-first-spatial-filtering">Accelerate  with a first spatial filtering</a></li>
</ul></li>
</ul></li>
<li><a href="#displays">Displays</a>
<ul>
<li><a href="#shape">shape</a></li>
<li><a href="#circle-vs-square--sphere-vs-cube">circle vs square / sphere vs cube</a></li>
<li><a href="#opengl-refresh-facets">OpenGL refresh facets</a></li>
</ul></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="machine-_time"></a><a href="#machine-_time" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>machine_time</h2>
<p>In order to optimize a model, it is important to exactly know which part of the model take times. The simplest to do that is to use the <strong>machine_time</strong> built-in global variable that gives the current time in milliseconds. Then to compute the time taken by a statement, a possible way is to write:</p>
<pre><code class="hljs"><span class="hljs-keyword">float</span> t &lt;- machine_time;
<span class="hljs-comment">// here a block of instructions that you consider as "critical"</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-built_in">write</span> <span class="hljs-string">"duration of the last instructions: "</span> + (machine_time - t);
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="scheduling"></a><a href="#scheduling" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scheduling</h2>
<p>If you have a species of agents that, once created, are not supposed to do anything more (i.e. no behavior, no reflex, their actions triggered by other agents, their attributes being simply read and written by other agents), such as a &quot;data&quot; grid, or agents representing a &quot;background&quot; (from a shape file, etc.), consider using the <code>schedules: []</code> facet on the definition of their species. This trick allows to tell GAMA to not schedule any of these agents.</p>
<pre><code class="hljs">grid my_grid <span class="hljs-string">height:</span> <span class="hljs-number">100</span> <span class="hljs-string">width:</span> <span class="hljs-number">100</span> <span class="hljs-string">schedules:</span> [] 
{
      ...
}
</code></pre>
<p>The <code>schedules:</code> facet is dynamically computed (even if the agents are not scheduled), so, if you happen to define agents that only need to be scheduled every x cycles, or depending on a condition, you can also write <code>schedules:</code> to implement this. For instance, the following species will see its instances scheduled every 10 steps and only if a certain condition is met:</p>
<pre><code class="hljs"><span class="hljs-selector-tag">species</span> <span class="hljs-selector-tag">my_species</span> <span class="hljs-selector-tag">schedules</span>: (every <span class="hljs-number">10</span>) ? (condition ? <span class="hljs-attribute">my_species </span>: []) : <span class="hljs-selector-attr">[]</span> 
{
     ...
}
</code></pre>
<p>In the same way, modelers can use the frequency facet to define when the agents of a species are going to be activated. By setting this facet to 0, the agents are never activated.</p>
<pre><code class="hljs">species my_species frequency: <span class="hljs-number">0</span>
{
     ...
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="grid"></a><a href="#grid" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Grid</h2>
<h3><a class="anchor" aria-hidden="true" id="optimization-facets"></a><a href="#optimization-facets" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optimization Facets</h3>
<p>In this section, we present some facets that allow to optimize the use of grid (in particular in terms of memories). Note that all these facet can be combined (see the Life model from the Models library).</p>
<h4><a class="anchor" aria-hidden="true" id="use-_regular-_agents"></a><a href="#use-_regular-_agents" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>use_regular_agents</h4>
<p>If false, then a special class of agents is used. This special class of agents used less memories but has some limitation: the agents cannot inherit from a &quot;normal&quot; species, they cannot have sub-populations, their name cannot be modified, etc.</p>
<pre><code class="hljs"><span class="hljs-string">grid</span> <span class="hljs-string">cell</span> <span class="hljs-attr">width:</span> <span class="hljs-number">50</span> <span class="hljs-attr">height:</span> <span class="hljs-number">50</span> <span class="hljs-attr">use_regular_agents:</span> <span class="hljs-literal">false</span> <span class="hljs-string">;</span>
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="use-_individual-_shapes"></a><a href="#use-_individual-_shapes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>use_individual_shapes</h4>
<p>If false, then only one geometry is used for all agents. This facet allows to gain a lot of memory, but should not be used if the geometries of the agents are often activated (for instance, by an aspect).</p>
<pre><code class="hljs"><span class="hljs-string">grid</span> <span class="hljs-string">cell</span> <span class="hljs-attr">width:</span> <span class="hljs-number">50</span> <span class="hljs-attr">height:</span> <span class="hljs-number">50</span> <span class="hljs-attr">use_individual_shapes:</span> <span class="hljs-literal">false</span> <span class="hljs-string">;</span>   
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="operators"></a><a href="#operators" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Operators</h2>
<h3><a class="anchor" aria-hidden="true" id="list-operators"></a><a href="#list-operators" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>List operators</h3>
<h4><a class="anchor" aria-hidden="true" id="first-_with"></a><a href="#first-_with" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>first_with</h4>
<p>It is sometimes necessary to randomly select an element of a list that verifies a certain condition.
Many modelers use the <strong>one_of</strong> and the <strong>where</strong> operators to do this:</p>
<pre><code class="hljs">bug one_big_bug &lt;- one_of (<span class="hljs-name">bug</span> where (<span class="hljs-name">each</span>.size &gt; <span class="hljs-number">10</span>))<span class="hljs-comment">;</span>
</code></pre>
<p>Whereas it is often more optimized to use the <strong>shuffle</strong> operator to shuffle the list, then the <strong>first_with</strong> operator to select the first element that verifies the condition:</p>
<pre><code class="hljs">bug one_big_bug &lt;- shuffle(<span class="hljs-name">bug</span>) first_with (<span class="hljs-name">each</span>.size &gt; <span class="hljs-number">10</span>)<span class="hljs-comment">;</span>
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="where-count"></a><a href="#where-count" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>where / count</h4>
<p>It is quite common to want to count the number of elements of a list or a container that verify a condition.
The obvious to do it is :</p>
<pre><code class="hljs">int n &lt;- length(<span class="hljs-name">my_container</span> where (<span class="hljs-name">each</span>.size &gt; <span class="hljs-number">10</span>))<span class="hljs-comment">;</span>
</code></pre>
<p>This will however create an intermediary list before counting it, and this operation can be time consuming if the number of elements is important. To alleviate this problem, GAMA includes an operator called <strong>count</strong> that will count the elements that verify the condition by iterating directly on the container (no useless list created) :</p>
<pre><code class="hljs"><span class="hljs-keyword">int</span> n &lt;- my_container <span class="hljs-keyword">count</span> (<span class="hljs-keyword">each</span>.<span class="hljs-keyword">size</span> &gt; <span class="hljs-number">10</span>);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="spatial-operators"></a><a href="#spatial-operators" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spatial operators</h3>
<h4><a class="anchor" aria-hidden="true" id="container-of-agents-in-closest-_to-at-_distance-overlapping-inside"></a><a href="#container-of-agents-in-closest-_to-at-_distance-overlapping-inside" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>container of agents in closest_to, at_distance, overlapping, inside</h4>
<p>Several spatial query operators (such as <strong>closest_to</strong>, <strong>at_distance</strong>, <strong>overlapping</strong> or <strong>inside</strong>) allow to restrict the agents being queried to a container of agents. For instance, one can write:</p>
<pre><code class="hljs">agent <span class="hljs-keyword">closest_agent </span>&lt;- a_container_containing_agents <span class="hljs-keyword">closest_to </span>self<span class="hljs-comment">;</span>
</code></pre>
<p>This expression is formally equivalent to :</p>
<pre><code class="hljs">agent <span class="hljs-keyword">closest_agent </span>&lt;- a_container_containing_agent with_min_of (each <span class="hljs-keyword">distance_to </span>self)<span class="hljs-comment">;</span>
</code></pre>
<p>But it is much faster <strong>if your container is large</strong>, as it will query the agents using a spatial index (instead of browsing through the whole container). Note that in some cases, when you have a small number of agents, the first syntax will be faster. The same applies for the other operators.</p>
<p>Now consider a very common case: you need to restrict the agents being queried, not to a container, but to a species (which, actually, acts as a container in most cases). For instance, you want to know which predator is the closest to the current agent. If we apply the pattern above, we would write:</p>
<pre><code class="hljs">predator <span class="hljs-keyword">closest_predator </span>&lt;- predator with_min_of (each <span class="hljs-keyword">distance_to </span>self)<span class="hljs-comment">;</span>
</code></pre>
<p>or</p>
<pre><code class="hljs">predator <span class="hljs-keyword">closest_predator </span>&lt;- list(predator) <span class="hljs-keyword">closest_to </span>self<span class="hljs-comment">;</span>
</code></pre>
<p>But these two operators can be painfully slow if your species has many instances (even in the second form). In that case, always prefer using <strong>directly</strong> the species as the left member:</p>
<pre><code class="hljs">predator <span class="hljs-keyword">closest_ </span>predator &lt;- predator <span class="hljs-keyword">closest_to </span>self<span class="hljs-comment">;</span>
</code></pre>
<p>Not only is the syntax clearer, but the speed gain can be phenomenal because, in that case, the list of instances is not used (we just check if the agent is an instance of the left species).</p>
<p>However, what happens if one wants to query instances belonging to 2 or more species ? If we follow our reasoning, the immediate way to write it would be (if predator 1 and predator 2 are two species):</p>
<pre><code class="hljs">agent closest_agent &lt;- (<span class="hljs-name">list</span>(<span class="hljs-name">predator1</span>) + list(<span class="hljs-name">predator2</span>)) closest_to self<span class="hljs-comment">; </span>
</code></pre>
<p>or, more simply:</p>
<pre><code class="hljs">agent <span class="hljs-keyword">closest_agent </span>&lt;- (predator1 + predator2) <span class="hljs-keyword">closest_to </span>self<span class="hljs-comment">;</span>
</code></pre>
<p>The first syntax suffers from the same problem than the previous syntax: GAMA has to browse through the list (created by the concatenation of the species populations) to filter agents. The solution, then, is again to use directly the species, as GAMA is clever enough to create a temporary &quot;fake&quot; population out of the concatenation of several species, which can be used exactly like a list of agents, but provides the advantages of a species population (no iteration made during filtering).</p>
<h4><a class="anchor" aria-hidden="true" id="accelerate-closest-_to-with-a-first-spatial-filtering"></a><a href="#accelerate-closest-_to-with-a-first-spatial-filtering" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Accelerate <strong>closest_to</strong> with a first spatial filtering</h4>
<p>The <strong>closest_to</strong> operator can sometimes be slow if numerous agents are concerned by this query. If the modeler is just interested by a small subset of agents, it is possible to apply a first spatial filtering on the agent list by using the <strong>at_distance</strong> operator.
For example, if the modeler wants first to do a spatial filtering of 10m:</p>
<pre><code class="hljs">agent <span class="hljs-keyword">closest_agent </span>&lt;- (predator1 at_distance <span class="hljs-number">10</span>) <span class="hljs-keyword">closest_to </span>self<span class="hljs-comment">;</span>
</code></pre>
<p>To be sure to find an agent, the modeler can use a test statement:</p>
<pre><code class="hljs">agent <span class="hljs-keyword">closest_agent </span>&lt;- (predator1 at_distance <span class="hljs-number">10</span>) <span class="hljs-keyword">closest_to </span>self<span class="hljs-comment">;</span>
if (<span class="hljs-keyword">closest_agent </span>= nil) {<span class="hljs-keyword">closest_agent </span> &lt;- predator1 <span class="hljs-keyword">closest_to </span>self<span class="hljs-comment">;}</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="displays"></a><a href="#displays" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Displays</h2>
<h3><a class="anchor" aria-hidden="true" id="shape"></a><a href="#shape" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>shape</h3>
<p>It is quite common to want to display an agent as a circle or a square. A common mistake is to mix up the shape to draw and the geometry of the agent in the model. If the modeler just wants to display a particular shape, he/she should not modify the agent geometry (which is a point by default), but just specify the shape to draw in the agent aspect.</p>
<pre><code class="hljs">species bug {
     <span class="hljs-keyword">int</span> size &lt;- <span class="hljs-keyword">rnd</span>(<span class="hljs-number">100</span>)<span class="hljs-comment">;</span>
    
      aspect <span class="hljs-keyword">circle</span> {
          draw <span class="hljs-keyword">circle</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">color</span>: °blue<span class="hljs-comment">;</span>
      }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="circle-vs-square-sphere-vs-cube"></a><a href="#circle-vs-square-sphere-vs-cube" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>circle vs square / sphere vs cube</h3>
<p>Note that in OpenGL and Java2D (the two rendering subsystems used in GAMA), creating and drawing a circle geometry is more time consuming than creating and drawing a square (or a rectangle). In the same way, drawing a sphere is more time consuming than drawing a cube. Hence, if you want to optimize your model displays and if the rendering does not explicitly need &quot;rounded&quot; agents, try to use squares/cubes rather than circles/spheres.</p>
<h3><a class="anchor" aria-hidden="true" id="opengl-refresh-facets"></a><a href="#opengl-refresh-facets" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OpenGL refresh facets</h3>
<p>In OpenGL display, it is possible to specify that it is not necessary to refresh a layer with the facet <strong>refresh</strong>. If a species of agents is never modified in terms of visualization (location, shape or color), you can set <strong>refresh</strong> to false. Example:</p>
<pre><code class="hljs"><span class="hljs-string">display</span> <span class="hljs-string">city_display_opengl</span> <span class="hljs-attr">type:</span> <span class="hljs-string">opengl{</span>
     <span class="hljs-string">species</span> <span class="hljs-string">building</span> <span class="hljs-attr">aspect:</span> <span class="hljs-string">base</span> <span class="hljs-attr">refresh:</span> <span class="hljs-literal">false</span><span class="hljs-string">;</span>
     <span class="hljs-string">species</span> <span class="hljs-string">road</span> <span class="hljs-attr">aspect:</span> <span class="hljs-string">base</span> <span class="hljs-attr">refresh:</span> <span class="hljs-literal">false</span><span class="hljs-string">;</span>
     <span class="hljs-string">species</span> <span class="hljs-string">people</span> <span class="hljs-attr">aspect:</span> <span class="hljs-string">base;</span>
<span class="hljs-string">}</span>
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#table-of-contents">Table of contents</a></li><li><a href="#machine-_time">machine_time</a></li><li><a href="#scheduling">Scheduling</a></li><li><a href="#grid">Grid</a><ul class="toc-headings"><li><a href="#optimization-facets">Optimization Facets</a></li></ul></li><li><a href="#operators">Operators</a><ul class="toc-headings"><li><a href="#list-operators">List operators</a></li><li><a href="#spatial-operators">Spatial operators</a></li></ul></li><li><a href="#displays">Displays</a><ul class="toc-headings"><li><a href="#shape">shape</a></li><li><a href="#circle-vs-square-sphere-vs-cube">circle vs square / sphere vs cube</a></li><li><a href="#opengl-refresh-facets">OpenGL refresh facets</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/BC2019-Gama-Site/" class="nav-home"><img src="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png" alt="GAMA-Platform" width="66" height="58"/></a><div><h5>Docs</h5><a href="/BC2019-Gama-Site/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/BC2019-Gama-Site/docs/en/doc2.html">Guides (or other categories)</a><a href="/BC2019-Gama-Site/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/BC2019-Gama-Site/en/users.html">User Showcase</a><a href="http://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/BC2019-Gama-Site/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2019 GAMA-Platform</section></footer></div></body></html>