<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Multi-Level Usage Balls, Groups and Clouds · GAMA-Platform</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="GAMA, modeling made easy"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Multi-Level Usage Balls, Groups and Clouds · GAMA-Platform"/><meta property="og:type" content="website"/><meta property="og:url" content="https://roiarthurb.github.io/BC2019-Gama-Site/"/><meta property="og:description" content="GAMA, modeling made easy"/><meta property="og:image" content="https://roiarthurb.github.io/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://roiarthurb.github.io/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><link rel="shortcut icon" href="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/atom.xml" title="GAMA-Platform Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/feed.xml" title="GAMA-Platform Blog RSS Feed"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js" async=""></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js" async=""></script><script type="text/javascript" src="/BC2019-Gama-Site/js/code-block-buttons.js" async=""></script><link rel="stylesheet" href="/BC2019-Gama-Site/css/main.css"/><script src="/BC2019-Gama-Site/js/codetabs.js"></script></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/BC2019-Gama-Site/"><img class="logo" src="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png" alt="GAMA-Platform"/><h2 class="headerTitleWithLogo">GAMA-Platform</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/BC2019-Gama-Site/docs/Home" target="_self">Docs</a></li><li class=""><a href="/BC2019-Gama-Site/help" target="_self">Help</a></li><li class=""><a href="/BC2019-Gama-Site/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Multi-Level Usage Balls, Groups and Clouds</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="balls-groups-and-clouds-multilevel-architecture"></a><a href="#balls-groups-and-clouds-multilevel-architecture" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Balls, Groups and Clouds Multilevel Architecture</h1>
<p>_Author : _</p>
<p>This model shows how to use multi-level architecture to group agents, and regroup groups. The operators capture is used to capture an agent by a group and change its species as a species contained by the group and defined in the group species section. The operator release is used to release contained agents and change them into an other species. The experiment shows ball moving randomly, and following other balls. When they are close to each other, they generate a group of balls with its own behavior. A group of group agents generate a cloud in the same way. When the number of balls contained inside the group is too high, the group disappears and releases all its balls repulsively.</p>
<p>Code of the model :</p>
<pre><code class="hljs">
model balls_groups_clouds

global { 
    // Parameters
    bool create_group &lt;- true; 
    bool create_cloud &lt;- false; 
    
    // Environment
    point environment_bounds &lt;- {500, 500}; 
    geometry shape &lt;- rectangle(environment_bounds) ;       
    
    //Define a inner environment smaller inside the environment
    int inner_bounds_x &lt;- (int((environment_bounds.x) / 20))  ;
    int inner_bounds_y &lt;- (int((environment_bounds.y) / 20))  ;
    int xmin &lt;- inner_bounds_x ;
    int ymin &lt;- inner_bounds_y ;       
    int xmax &lt;- int((environment_bounds.x) - inner_bounds_x) ;
    int ymax &lt;- int((environment_bounds.y) - inner_bounds_y) ;
    
    float MAX_DISTANCE &lt;- environment_bounds.x + environment_bounds.y  ;
    
    //Global variables for ball agents
    rgb ball_color &lt;- #green; 
    rgb chaos_ball_color &lt;- #red;
    float ball_size &lt;- float(3);  
    float ball_speed &lt;- float(1);
    float chaos_ball_speed &lt;- 8 * ball_speed;  
    int ball_number &lt;- 200 min: 2 max: 1000;  
    geometry ball_shape &lt;- circle (ball_size) ;
    float ball_separation &lt;- 6 * ball_size; 
    
    //Global variables for group agents
    int group_creation_distance &lt;- int(ball_separation + 1);
    int min_group_member &lt;- 3;
    int group_base_speed &lt;- (int(ball_speed * 1.5));
    int base_perception_range &lt;- int (environment_bounds.x / 100) min: 1 ;  
    int creation_frequency &lt;- 3;
    int update_frequency &lt;- 3;
    int merge_frequency &lt;- 3;
    float merge_possibility &lt;- 0.3;
    
    //Global variables for Clouds Agents
    int cloud_creation_distance &lt;- 30 const: true;
    int min_cloud_member &lt;- 3 const: true;
    int cloud_speed &lt;- 3 const: true;
    int cloud_perception_range &lt;- base_perception_range const: true ; 
    
    init {
        create ball number: ball_number ;
        create group_agents_viewer;
        create cloud_agents_viewer;
    }
    
    //The simulation will try to create group at each frequence cycle
    reflex create_groups when: ( create_group and ((cycle mod creation_frequency) = 0) ) {
        //create a list from all balls following the nearest ball
        list&lt;ball&gt; free_balls &lt;- ball where ((each.state) = 'follow_nearest_ball') ;

        if (length (free_balls) &gt; 1) {
            //Clustering of the balls according to their distance with at least a minimal number of balls in a group
            list&lt;list&lt;ball&gt;&gt; satisfying_ball_groups &lt;- (free_balls simple_clustering_by_distance group_creation_distance) where ( (length (each)) &gt; min_group_member ) ;
            
            
            loop one_group over: satisfying_ball_groups {
                create group returns: new_groups;
                
                //Capture by the new groups created of the different balls present in the list one_group
                ask (new_groups at 0) as: group {
                    capture one_group as: ball_in_group; 
                }
            }
        }
    }
    
    //The simulation will try to create clouds at each frequence cycle
    reflex create_clouds when: (create_cloud and ((cycle mod creation_frequency) = 0) ) {
        //A cloud can be created only using group with a number of balls inside greater than 5% of the total ball number
        list&lt;group&gt; candidate_groups &lt;- group where (length(each.members) &gt; (0.05 * ball_number) );
        
        //A cloud can be created also only using group which aren't too far away 
        list&lt;list&lt;group&gt;&gt; satisfying_groups &lt;- (candidate_groups simple_clustering_by_distance cloud_creation_distance) where (length(each) &gt;= min_cloud_member);
        
        //Creation of the different clouds using the groups satisfying both conditions
        loop one_group over: satisfying_groups {
            create cloud returns: rets;         
            cloud newCloud &lt;- rets at 0; 
            ask newCloud as: cloud {
                capture one_group as: group_delegation;
            }

            loop gd over: (newCloud.members) {
                ask gd as group_delegation {
                    migrate ball_in_group target: ball_in_cloud;
                }
            } 
            
            newCloud.color &lt;- ((group_delegation(one_of(newCloud.members))).color).darker;
        }
    }
}
    //Base species with just the skills moving and all built-in variables and operators derivated from it
    species base skills: [moving] ;
    
    //Species with a specified type of control architecture, here the final state machine FSM
    species ball parent: base control: fsm  { 
        
        float speed &lt;- ball_speed; 
        rgb color &lt;- ball_color;
        int beginning_chaos_time; 
        int time_in_chaos_state;
        
        //create the ball in a certain way to not make balls intersect each other
        init {
            bool continue_loop &lt;- true ; 
            loop while: continue_loop {
                point tmp_location &lt;- {(rnd (xmax - xmin)) + xmin, (rnd (ymax - ymin)) + ymin} ;
                geometry potential_geom &lt;- ball_shape at_location tmp_location ; 
                
                if ( empty ( ball where  ( each intersects potential_geom ) ) )  {
                    location &lt;- tmp_location ;
                    continue_loop &lt;- false ;
                }
            }
        }
        
        //Action used to separate the balls and make them repulsive for the other balls of the group
        action separation (list&lt;ball&gt; nearby_balls) {
            float repulsive_dx &lt;- 0.0 ;
            float repulsive_dy &lt;- 0.0 ;
            loop nb over: nearby_balls { 
                float repulsive_distance &lt;- ball_separation - ( location distance_to ( nb).location ) ;
                int repulsive_direction &lt;- ((nb).location) towards (location) ;
                repulsive_dx &lt;- repulsive_dx + (repulsive_distance * (cos (repulsive_direction))) ;
                repulsive_dy &lt;- repulsive_dy + (repulsive_distance * (sin (repulsive_direction))) ;
            }
            location &lt;- location + {repulsive_dx, repulsive_dy} ;
        }
        
        bool in_bounds (point a_point) {
            return ( !(a_point.x &lt; xmin) and !(a_point.x &gt; xmax) and !(a_point.y &lt; ymin) and !(a_point.y &gt; ymax) ) ;
        }
         
        //State that will make the agent follows the closest ball if it is not in the chaos state anymore
        state follow_nearest_ball initial: true {
            enter {   
                color &lt;- ball_color ;
                speed &lt;- ball_speed ;
            }
            list&lt;ball&gt; free_balls &lt;- (list (ball) - self) where ((each.state) = 'follow_nearest_ball') ;
            ball nearest_free_ball &lt;- free_balls closest_to self;
            if nearest_free_ball != nil {
                heading &lt;- self towards (nearest_free_ball) ; 
                float step_distance &lt;- speed * step ;
                float step_x &lt;- step_distance * (cos (heading)) ;
                float step_y &lt;- step_distance * (sin (heading)) ; 
                point tmp_location &lt;- location + {step_x, step_y} ;
                if (self in_bounds (tmp_location) ) {
                    location &lt;- tmp_location ;
                    do separation (((ball overlapping (shape + ball_separation)) - self));
                }
            }
        }
        
        //Make the ball move randomly during a certain time
        state chaos {
            enter {
                beginning_chaos_time &lt;- int(time) ;
                time_in_chaos_state &lt;- 10 + (rnd(10)) ;
                color &lt;- chaos_ball_color ;
                speed &lt;- chaos_ball_speed ;
                heading &lt;- rnd(359) ;
            }
            
            float step_distance &lt;- speed * step ;
            float step_x &lt;- step_distance * (cos (heading)) ;
            float step_y &lt;- step_distance * (sin (heading)) ;
            point tmp_location &lt;- location + {step_x, step_y} ;
            if (self in_bounds (tmp_location)) {
                location &lt;- tmp_location ;
                do separation (nearby_balls: (ball overlapping (shape + ball_separation)) - self);
            }
            
            transition to: follow_nearest_ball when: time &gt; (beginning_chaos_time + time_in_chaos_state) ;
        }
        
        aspect default {
            draw ball_shape color: color size: ball_size at:self.location;
        }
    }
    
    //Species representing the group of balls
    species group parent: base { 
        
        rgb color &lt;- rgb ([ rnd(255), rnd(255), rnd(255) ]) ;
        geometry shape &lt;- polygon (ball_in_group) buffer  10 ;
        float speed update: float(group_base_speed) ;
        
        //Parameter to capture the balls contains in the perception range
        float perception_range update: float(base_perception_range + (rnd(5))) ;
        
        ball nearest_free_ball update: ( ball where ( (each.state = 'follow_nearest_ball') ) ) closest_to self ;
        group nearest_smaller_group update: ( ( (group as list) - self ) where ( (length (each.members)) &lt; (length (members)) ) ) closest_to self ;
        base target update: (self get_nearer_target []) depends_on: [nearest_free_ball, nearest_smaller_group] ;
         
        //Function to return the closest ball or small group of balls that the agent could capture
        base get_nearer_target {
            if  (nearest_free_ball = nil) and (nearest_smaller_group = nil) {
                return nil ;
            }
            
            float distance_to_ball &lt;- (nearest_free_ball != nil) ? (self distance_to nearest_free_ball) : MAX_DISTANCE ;
            float distance_to_group &lt;- (nearest_smaller_group != nil) ? (self distance_to nearest_smaller_group) : MAX_DISTANCE ;
            if (distance_to_ball &lt; distance_to_group) {
                return nearest_free_ball ;
            }
             
            return nearest_smaller_group ;
        }
        
        //Action to use when the group of balls explode
        action separate_components {
            loop com over: (list (ball_in_group)) {
                list&lt;ball_in_group&gt; nearby_balls &lt;-  ((ball_in_group overlapping (com.shape + ball_separation)) - com) where (each in members) ;
                float repulsive_dx &lt;- 0.0 ;
                float repulsive_dy &lt;- 0.0 ;
                loop nb over: nearby_balls { 
                    float repulsive_distance &lt;- ball_separation - ( (ball_in_group (com)).location distance_to nb.location ) ;
                    int repulsive_direction &lt;- (nb.location) direction_to ((ball_in_group (com)).location) ;
                    repulsive_dx &lt;- repulsive_dx + (repulsive_distance * (cos (repulsive_direction))) ;
                    repulsive_dy &lt;- repulsive_dy + (repulsive_distance * (sin (repulsive_direction))) ;
                }
                
                (ball_in_group (com)).location &lt;- (ball_in_group (com)).location + {repulsive_dx, repulsive_dy} ;
            }
        }
        
        //Species that will represent the balls captured by the group agent
        species ball_in_group parent: ball topology: topology((world).shape)  {
            
            float my_age &lt;- 1.0 update: my_age + 0.01;
             
            state follow_nearest_ball initial: true { }
            
            state chaos { }
            
            aspect default {
                draw circle(my_age) color: ((host as group).color).darker ;
            }
        }
        
        //Reflex to capture all the balls close to the group agent
        reflex capture_nearby_free_balls when: (cycle mod update_frequency) = 0 {
            list&lt;ball&gt; nearby_free_balls &lt;- (ball overlapping (shape + perception_range)) where (each.state = 'follow_nearest_ball');
            if !(empty (nearby_free_balls)) {
                capture nearby_free_balls as: ball_in_group;
            }
        }
        
        //Action to do when the group is disaggregated
        action disaggregate {
            release members as: ball in: world {
                 state &lt;- 'chaos' ;
            }
            
            do die ;
        }
        
        //Reflex to merge the group close to the agent when the cycle is in the frequency of merging
        reflex merge_nearby_groups when: (cycle mod merge_frequency) = 0 {
            if ( (target != nil) and ((species_of (target)) = group) ) {
                list&lt;group&gt; nearby_groups &lt;- (group overlapping (shape + perception_range)) - self ;
                
                if target in nearby_groups {
                    if (rnd(10)) &lt; (merge_possibility * 10) {
                        list&lt;ball_in_group&gt; target_coms &lt;- list&lt;ball_in_group&gt;(target.members) ;
                        list&lt;ball&gt; released_balls ;
                        ask target {
                            release target_coms as: ball in: world returns: released_coms;
                            released_balls &lt;- list(released_coms);
                            do die ;
                        }
                        capture released_balls as: ball_in_group; 
                    }
                else { ask target as group {do disaggregate ;} }
                }
            }
        }
        
        //Reflex to chase a target agent 
        reflex chase_target when: (target != nil) {
            int direction_to_nearest_ball &lt;- (self towards (target)) ;
            float step_distance &lt;- speed * step ;
            float dx &lt;- step_distance * (cos (direction_to_nearest_ball)) ;
            float dy &lt;- step_distance * (sin (direction_to_nearest_ball)) ;
            geometry envelope &lt;- shape.envelope ;
            point topleft_point &lt;- (envelope.points) at 0 ;
            point bottomright_point &lt;- (envelope.points) at 0 ;
            
            loop p over: envelope.points {
                if ( (p.x &lt;= topleft_point.x) and (p.y &lt;= topleft_point.y) ) {
                    topleft_point &lt;- p ;
                }
                
                if ( (p.x &gt;= bottomright_point.x) and (p.y &gt;= bottomright_point.y) ) {
                    bottomright_point &lt;- p ;
                }
            }
            
            if ( (dx + topleft_point.x) &lt; 0 ) {
                float tmp_dx &lt;- dx + topleft_point.x ;
                dx &lt;- dx - tmp_dx ;
            } else {
                if (dx + bottomright_point.x) &gt; (environment_bounds.x) {
                    float tmp_dx &lt;- (dx + bottomright_point.x) - environment_bounds.x ;
                    dx &lt;- dx - tmp_dx ;
                }
            }
            
            if (dy + topleft_point.y) &lt; 0 {
                float tmp_dy &lt;- dy + topleft_point.y ;
                dy &lt;- dy - tmp_dy ;
            } else {
                if (dy + topleft_point.y) &gt; (environment_bounds.y) {
                    float tmp_dy &lt;- (dy + bottomright_point.y) - (environment_bounds.y) ;
                    dy &lt;- dy - tmp_dy ;
                }
            }
            
            loop com over: (list (ball_in_group)) {
                (ball_in_group (com)).location &lt;- (ball_in_group (com)).location + {dx, dy} ;
            }
            
            shape &lt;- convex_hull((polygon ((list (ball_in_group)) collect (ball_in_group (each)).location)) + 2.0) ;
        }
        //Reflex to disaggregate the group if it is too important ie the number of balls is greater than 80% of the total ball number
        reflex self_disaggregate {
            if ( ( length (members) ) &gt; ( 0.8 * (ball_number) ) ) {
                do disaggregate ;
            }
        }
        
        aspect default {
            draw shape color: color;
        }
    }
    
    //Species cloud that will be created by an agglomeration of groups.
    species cloud parent: base {
        geometry shape &lt;- convex_hull(polygon(members collect (((group_delegation(each)).shape).location))) update: convex_hull(polygon(members collect (((group_delegation(each)).shape).location)));

        rgb color;
        
        //Species contained in the cloud to represent the groups captured by the cloud agent
        species group_delegation parent: group topology: (topology(world.shape)) {
            geometry shape &lt;- convex_hull( (polygon ( (list (ball_in_cloud)) collect (each.location) )) ) buffer 10 update: convex_hull( (polygon ( (list (ball_in_cloud)) collect (each.location) )) ) buffer  10 ;

            reflex capture_nearby_free_balls when: false {
            }
            
            reflex merge_nearby_groups when: false {
            }
            
            reflex chase_target when: false {
            }
            
            reflex self_disaggregate {
            }
            
            action move2 (float with_heading, float with_speed) {

                loop m over: members {
                    ask m as ball_in_cloud {
                        do move2 (with_heading,with_speed);
                    }
                }
            }
             
            species ball_in_cloud parent: ball_in_group topology: (world.shape) as topology control: fsm {
                
                action move2 (float with_heading, float with_speed) {
                    float dx &lt;- cos(with_heading) * with_speed;
                    float dy &lt;- sin(with_heading) * with_speed;
                    location &lt;- { ( (location.x) + dx ), ( (location.y) + dy )};
                }
                
                aspect default {}               
            }
        }
        
        group target_group;
    
        //The cloud try to look for small groups to capture them
        reflex chase_group {
            if ( (target_group = nil) or (dead(target_group)) ) {
                target_group &lt;- one_of(group);
            }
            
            if (target_group != nil) {
                int direction_target &lt;- self towards(target_group);
                
                loop m over: members {
                    ask m as group_delegation {
                        do move2 with: [ with_heading :: float(direction_target), with_speed :: float(cloud_speed) ];
                    }               
                }
            }
        }
        
        //Operator to know if a cloud can capture a group overlapping the cloud agent. 
        bool can_capture (group a_group) {
            
            if (shape overlaps a_group.shape) { return true; }
            
            loop gd over: members {
                if ( (a_group.shape) overlaps ( ( group_delegation(gd)).shape ) ) { return true; }
            }
            
            return false;
        }
        
        //Reflex to capture group
        reflex capture_group {
            if ( (target_group != nil) and !(dead(target_group)) ) {
                if (self can_capture [ a_group :: target_group]) {

                    capture target_group as: group_delegation returns: gds;
    
                    ask (gds at 0) as: group_delegation {
                        migrate ball_in_group target: ball_in_cloud;
                    }
                }
            }
        }
        
        //Reflex to disaggregate the clouds when they are no more group to capture
        reflex disaggregate when: (empty(list(group))) {
            loop m over: members {
                ask group_delegation(m) as: group_delegation {
                    migrate ball_in_cloud target: ball_in_group;
                }
            }
            
            release members as: group in: world returns: r_groups;
            
            loop rg over: r_groups {
                ask rg as: group { do disaggregate; }
            }
            
            do die; 
        }
         
        aspect default {
            draw shape color: color empty: true;
            draw (name + ' with ' + (string(length(members))) + ' groups.') size: 15 color: color  at: {location.x - 65, location.y};
        }
    }
    
    species group_agents_viewer  { 
        aspect default {
            draw ('Number of groups: ' + (string (length (world.agents of_generic_species group)))) at: {(environment_bounds.x)/2 - 210, (environment_bounds.y)/2} color: #blue size: 40  ;
        }
    }

    species cloud_agents_viewer  { 
        aspect default {
            draw ('Number of clouds: ' + (string (length (list(cloud))))) at: {(environment_bounds.x)/2 - 210, (environment_bounds.y)/2} color: #green size: 40 ;
        }
    } 


experiment group_experiment type: gui {
    parameter 'Create groups?' var: create_group &lt;- true;
    parameter 'Create clouds?' var: create_cloud &lt;- false;
        
    output {
        display 'Standard display' {
            species ball aspect: default transparency: 0.5 ;
            
            species group aspect: default transparency: 0.5 {
                species ball_in_group;
            }
        }
        
        display 'Ball display' {
            species ball;
        }
        
        display 'Group display' {
            species group;
            species group_agents_viewer;
        }
    }
}

experiment cloud_experiment type: gui {

    parameter 'Create groups?' var: create_group &lt;- true;
    parameter 'Create clouds?' var: create_cloud &lt;- true;
        
    output {
        display 'Standard display' {
            species ball aspect: default transparency: 0.5 ;
            
            species group aspect: default transparency: 0.5 {
                species ball_in_group;
            }
            
            species cloud aspect: default {
                species group_delegation transparency: 0.9 {
                    species ball_in_cloud;
                    species ball_in_group;
                }
            }
        }
        
        display 'Ball display' {
            species ball;
        }
        
        display 'Group display' {
            species group;
            species group_agents_viewer;
        }

        display 'Cloud display' {
            species cloud;
        }
        
        monitor "Balls" value: length(ball);
        monitor "Groups" value: length(group);
        monitor "Clouds" value: length(cloud);
    }
}

</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/BC2019-Gama-Site/" class="nav-home"><img src="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png" alt="GAMA-Platform" width="66" height="58"/></a><div><h5>Docs</h5><a href="/BC2019-Gama-Site/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/BC2019-Gama-Site/docs/en/doc2.html">Guides (or other categories)</a><a href="/BC2019-Gama-Site/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/BC2019-Gama-Site/en/users.html">User Showcase</a><a href="http://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/BC2019-Gama-Site/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2019 GAMA-Platform</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0f9f28b9ab9efae89810921a351753b5',
                indexName: 'github',
                inputSelector: '#search_input_react'
              });
            </script></body></html>