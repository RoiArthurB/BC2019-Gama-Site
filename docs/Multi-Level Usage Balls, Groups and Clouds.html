<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Balls, Groups and Clouds Multilevel Architecture · GAMA-Platform</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="GAMA"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Balls, Groups and Clouds Multilevel Architecture · GAMA-Platform"/><meta property="og:type" content="website"/><meta property="og:url" content="https://roiarthurb.github.io/BC2019-Gama-Site/"/><meta property="og:description" content="GAMA"/><meta property="og:image" content="https://roiarthurb.github.io/BC2019-Gama-Site//resources/images/general/GamaPlatform.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://roiarthurb.github.io/BC2019-Gama-Site//resources/images/general/GamaPlatform.png"/><link rel="shortcut icon" href="/BC2019-Gama-Site//img/gama-logo.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js" async=""></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js" async=""></script><script type="text/javascript" src="/BC2019-Gama-Site/js/code-block-buttons.js" async=""></script><link rel="stylesheet" href="/BC2019-Gama-Site/css/main.css"/><script src="/BC2019-Gama-Site/js/codetabs.js"></script></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/BC2019-Gama-Site/"><img class="logo" src="/BC2019-Gama-Site//img/gama-logo_white.png" alt="GAMA-Platform"/><h2 class="headerTitleWithLogo">GAMA-Platform</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/BC2019-Gama-Site/docs/Home" target="_self">Documentation</a></li><li class=""><a href="/BC2019-Gama-Site/docs/Tutorials" target="_self">Tutorials</a></li><li class=""><a href="/BC2019-Gama-Site/help" target="_self">Download</a></li><li class=""><a href="/BC2019-Gama-Site/help" target="_self">Contribute</a></li><li class=""><a target="_self">Blog</a></li><li class=""><a target="_self"></a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Balls, Groups and Clouds Multilevel Architecture</h1></header><article><div><span><p>_Author : _</p>
<p>This model shows how to use multi-level architecture to group agents, and regroup groups. The operators capture is used to capture an agent by a group and change its species as a species contained by the group and defined in the group species section. The operator release is used to release contained agents and change them into an other species. The experiment shows ball moving randomly, and following other balls. When they are close to each other, they generate a group of balls with its own behavior. A group of group agents generate a cloud in the same way. When the number of balls contained inside the group is too high, the group disappears and releases all its balls repulsively.</p>
<p>Code of the model :</p>
<pre><code class="hljs">
model balls_groups_clouds

global { 
    <span class="hljs-comment">// Parameters</span>
    bool create_group &lt;- true; 
    bool create_cloud &lt;- false; 
    
    <span class="hljs-comment">// Environment</span>
    point environment_bounds &lt;- {500, 500}; 
    geometry shape &lt;- rectangle(environment_bounds) ;       
    
    <span class="hljs-comment">//Define a inner environment smaller inside the environment</span>
    int inner_bounds_x &lt;- (int((environment_bounds.x) / 20))  ;
    int inner_bounds_y &lt;- (int((environment_bounds.y) / 20))  ;
    int xmin &lt;- inner_bounds_x ;
    int ymin &lt;- inner_bounds_y ;       
    int xmax &lt;- int((environment_bounds.x) - inner_bounds_x) ;
    int ymax &lt;- int((environment_bounds.y) - inner_bounds_y) ;
    
    float MAX_DISTANCE &lt;- environment_bounds.x + environment_bounds.y  ;
    
    <span class="hljs-comment">//Global variables for ball agents</span>
    rgb ball_color &lt;- #green; 
    rgb chaos_ball_color &lt;- #red;
    float ball_size &lt;- float(3);  
    float ball_speed &lt;- float(1);
    float chaos_ball_speed &lt;- 8 * ball_speed;  
    int ball_number &lt;- 200 min: 2 max: 1000;  
    geometry ball_shape &lt;- circle (ball_size) ;
    float ball_separation &lt;- 6 * ball_size; 
    
    <span class="hljs-comment">//Global variables for group agents</span>
    int group_creation_distance &lt;- int(ball_separation + 1);
    int min_group_member &lt;- 3;
    int group_base_speed &lt;- (int(ball_speed * 1.5));
    int base_perception_range &lt;- int (environment_bounds.x / 100) min: 1 ;  
    int creation_frequency &lt;- 3;
    int update_frequency &lt;- 3;
    int merge_frequency &lt;- 3;
    float merge_possibility &lt;- 0.3;
    
    <span class="hljs-comment">//Global variables for Clouds Agents</span>
    int cloud_creation_distance &lt;- 30 const: true;
    int min_cloud_member &lt;- 3 const: true;
    int cloud_speed &lt;- 3 const: true;
    int cloud_perception_range &lt;- base_perception_range const: true ; 
    
    init {
        create ball number: ball_number ;
        create group_agents_viewer;
        create cloud_agents_viewer;
    }
    
    <span class="hljs-comment">//The simulation will try to create group at each frequence cycle</span>
    reflex create_groups when: ( create_group and ((cycle mod creation_frequency) = 0) ) {
        <span class="hljs-comment">//create a list from all balls following the nearest ball</span>
        list&lt;ball&gt; free_balls &lt;- ball where ((each.state) = <span class="hljs-string">'follow_nearest_ball'</span>) ;

        if (length (free_balls) &gt; 1) {
            <span class="hljs-comment">//Clustering of the balls according to their distance with at least a minimal number of balls in a group</span>
            list&lt;list&lt;ball&gt;&gt; satisfying_ball_groups &lt;- (free_balls simple_clustering_by_distance group_creation_distance) where ( (length (each)) &gt; min_group_member ) ;
            
            
            loop one_group over: satisfying_ball_groups {
                create group returns: new_groups;
                
                <span class="hljs-comment">//Capture by the new groups created of the different balls present in the list one_group</span>
                ask (new_groups at 0) as: group {
                    capture one_group as: ball_in_group; 
                }
            }
        }
    }
    
    <span class="hljs-comment">//The simulation will try to create clouds at each frequence cycle</span>
    reflex create_clouds when: (create_cloud and ((cycle mod creation_frequency) = 0) ) {
        <span class="hljs-comment">//A cloud can be created only using group with a number of balls inside greater than 5% of the total ball number</span>
        list&lt;group&gt; candidate_groups &lt;- group where (length(each.members) &gt; (0.05 * ball_number) );
        
        <span class="hljs-comment">//A cloud can be created also only using group which aren't too far away </span>
        list&lt;list&lt;group&gt;&gt; satisfying_groups &lt;- (candidate_groups simple_clustering_by_distance cloud_creation_distance) where (length(each) &gt;= min_cloud_member);
        
        <span class="hljs-comment">//Creation of the different clouds using the groups satisfying both conditions</span>
        loop one_group over: satisfying_groups {
            create cloud returns: rets;         
            cloud newCloud &lt;- rets at 0; 
            ask newCloud as: cloud {
                capture one_group as: group_delegation;
            }

            loop gd over: (newCloud.members) {
                ask gd as group_delegation {
                    migrate ball_in_group target: ball_in_cloud;
                }
            } 
            
            newCloud.color &lt;- ((group_delegation(one_of(newCloud.members))).color).darker;
        }
    }
}
    <span class="hljs-comment">//Base species with just the skills moving and all built-in variables and operators derivated from it</span>
    species base skills: [moving] ;
    
    <span class="hljs-comment">//Species with a specified type of control architecture, here the final state machine FSM</span>
    species ball parent: base control: fsm  { 
        
        float speed &lt;- ball_speed; 
        rgb color &lt;- ball_color;
        int beginning_chaos_time; 
        int time_in_chaos_state;
        
        <span class="hljs-comment">//create the ball in a certain way to not make balls intersect each other</span>
        init {
            bool continue_loop &lt;- true ; 
            loop while: continue_loop {
                point tmp_location &lt;- {(rnd (xmax - xmin)) + xmin, (rnd (ymax - ymin)) + ymin} ;
                geometry potential_geom &lt;- ball_shape at_location tmp_location ; 
                
                if ( empty ( ball where  ( each intersects potential_geom ) ) )  {
                    location &lt;- tmp_location ;
                    continue_loop &lt;- false ;
                }
            }
        }
        
        <span class="hljs-comment">//Action used to separate the balls and make them repulsive for the other balls of the group</span>
        action separation (list&lt;ball&gt; nearby_balls) {
            float repulsive_dx &lt;- 0.0 ;
            float repulsive_dy &lt;- 0.0 ;
            loop nb over: nearby_balls { 
                float repulsive_distance &lt;- ball_separation - ( location distance_to ( nb).location ) ;
                int repulsive_direction &lt;- ((nb).location) towards (location) ;
                repulsive_dx &lt;- repulsive_dx + (repulsive_distance * (cos (repulsive_direction))) ;
                repulsive_dy &lt;- repulsive_dy + (repulsive_distance * (sin (repulsive_direction))) ;
            }
            location &lt;- location + {repulsive_dx, repulsive_dy} ;
        }
        
        bool in_bounds (point a_point) {
            return ( !(a_point.x &lt; xmin) and !(a_point.x &gt; xmax) and !(a_point.y &lt; ymin) and !(a_point.y &gt; ymax) ) ;
        }
         
        <span class="hljs-comment">//State that will make the agent follows the closest ball if it is not in the chaos state anymore</span>
        state follow_nearest_ball initial: true {
            enter {   
                color &lt;- ball_color ;
                speed &lt;- ball_speed ;
            }
            list&lt;ball&gt; free_balls &lt;- (list (ball) - self) where ((each.state) = <span class="hljs-string">'follow_nearest_ball'</span>) ;
            ball nearest_free_ball &lt;- free_balls closest_to self;
            if nearest_free_ball != <span class="hljs-literal">nil</span> {
                heading &lt;- self towards (nearest_free_ball) ; 
                float step_distance &lt;- speed * step ;
                float step_x &lt;- step_distance * (cos (heading)) ;
                float step_y &lt;- step_distance * (sin (heading)) ; 
                point tmp_location &lt;- location + {step_x, step_y} ;
                if (self in_bounds (tmp_location) ) {
                    location &lt;- tmp_location ;
                    do separation (((ball overlapping (shape + ball_separation)) - self));
                }
            }
        }
        
        <span class="hljs-comment">//Make the ball move randomly during a certain time</span>
        state chaos {
            enter {
                beginning_chaos_time &lt;- int(time) ;
                time_in_chaos_state &lt;- 10 + (rnd(10)) ;
                color &lt;- chaos_ball_color ;
                speed &lt;- chaos_ball_speed ;
                heading &lt;- rnd(359) ;
            }
            
            float step_distance &lt;- speed * step ;
            float step_x &lt;- step_distance * (cos (heading)) ;
            float step_y &lt;- step_distance * (sin (heading)) ;
            point tmp_location &lt;- location + {step_x, step_y} ;
            if (self in_bounds (tmp_location)) {
                location &lt;- tmp_location ;
                do separation (nearby_balls: (ball overlapping (shape + ball_separation)) - self);
            }
            
            transition to: follow_nearest_ball when: time &gt; (beginning_chaos_time + time_in_chaos_state) ;
        }
        
        aspect default {
            draw ball_shape color: color size: ball_size at:self.location;
        }
    }
    
    <span class="hljs-comment">//Species representing the group of balls</span>
    species group parent: base { 
        
        rgb color &lt;- rgb ([ rnd(255), rnd(255), rnd(255) ]) ;
        geometry shape &lt;- polygon (ball_in_group) buffer  10 ;
        float speed update: float(group_base_speed) ;
        
        <span class="hljs-comment">//Parameter to capture the balls contains in the perception range</span>
        float perception_range update: float(base_perception_range + (rnd(5))) ;
        
        ball nearest_free_ball update: ( ball where ( (each.state = <span class="hljs-string">'follow_nearest_ball'</span>) ) ) closest_to self ;
        group nearest_smaller_group update: ( ( (group as list) - self ) where ( (length (each.members)) &lt; (length (members)) ) ) closest_to self ;
        base target update: (self get_nearer_target []) depends_on: [nearest_free_ball, nearest_smaller_group] ;
         
        <span class="hljs-comment">//Function to return the closest ball or small group of balls that the agent could capture</span>
        base get_nearer_target {
            if  (nearest_free_ball = <span class="hljs-literal">nil</span>) and (nearest_smaller_group = <span class="hljs-literal">nil</span>) {
                return <span class="hljs-literal">nil</span> ;
            }
            
            float distance_to_ball &lt;- (nearest_free_ball != <span class="hljs-literal">nil</span>) ? (self distance_to nearest_free_ball) : MAX_DISTANCE ;
            float distance_to_group &lt;- (nearest_smaller_group != <span class="hljs-literal">nil</span>) ? (self distance_to nearest_smaller_group) : MAX_DISTANCE ;
            if (distance_to_ball &lt; distance_to_group) {
                return nearest_free_ball ;
            }
             
            return nearest_smaller_group ;
        }
        
        <span class="hljs-comment">//Action to use when the group of balls explode</span>
        action separate_components {
            loop com over: (list (ball_in_group)) {
                list&lt;ball_in_group&gt; nearby_balls &lt;-  ((ball_in_group overlapping (com.shape + ball_separation)) - com) where (each in members) ;
                float repulsive_dx &lt;- 0.0 ;
                float repulsive_dy &lt;- 0.0 ;
                loop nb over: nearby_balls { 
                    float repulsive_distance &lt;- ball_separation - ( (ball_in_group (com)).location distance_to nb.location ) ;
                    int repulsive_direction &lt;- (nb.location) direction_to ((ball_in_group (com)).location) ;
                    repulsive_dx &lt;- repulsive_dx + (repulsive_distance * (cos (repulsive_direction))) ;
                    repulsive_dy &lt;- repulsive_dy + (repulsive_distance * (sin (repulsive_direction))) ;
                }
                
                (ball_in_group (com)).location &lt;- (ball_in_group (com)).location + {repulsive_dx, repulsive_dy} ;
            }
        }
        
        <span class="hljs-comment">//Species that will represent the balls captured by the group agent</span>
        species ball_in_group parent: ball topology: topology((world).shape)  {
            
            float my_age &lt;- 1.0 update: my_age + 0.01;
             
            state follow_nearest_ball initial: true { }
            
            state chaos { }
            
            aspect default {
                draw circle(my_age) color: ((host as group).color).darker ;
            }
        }
        
        <span class="hljs-comment">//Reflex to capture all the balls close to the group agent</span>
        reflex capture_nearby_free_balls when: (cycle mod update_frequency) = 0 {
            list&lt;ball&gt; nearby_free_balls &lt;- (ball overlapping (shape + perception_range)) where (each.state = <span class="hljs-string">'follow_nearest_ball'</span>);
            if !(empty (nearby_free_balls)) {
                capture nearby_free_balls as: ball_in_group;
            }
        }
        
        <span class="hljs-comment">//Action to do when the group is disaggregated</span>
        action disaggregate {
            release members as: ball in: world {
                 state &lt;- <span class="hljs-string">'chaos'</span> ;
            }
            
            do die ;
        }
        
        <span class="hljs-comment">//Reflex to merge the group close to the agent when the cycle is in the frequency of merging</span>
        reflex merge_nearby_groups when: (cycle mod merge_frequency) = 0 {
            if ( (target != <span class="hljs-literal">nil</span>) and ((species_of (target)) = group) ) {
                list&lt;group&gt; nearby_groups &lt;- (group overlapping (shape + perception_range)) - self ;
                
                if target in nearby_groups {
                    if (rnd(10)) &lt; (merge_possibility * 10) {
                        list&lt;ball_in_group&gt; target_coms &lt;- list&lt;ball_in_group&gt;(target.members) ;
                        list&lt;ball&gt; released_balls ;
                        ask target {
                            release target_coms as: ball in: world returns: released_coms;
                            released_balls &lt;- list(released_coms);
                            do die ;
                        }
                        capture released_balls as: ball_in_group; 
                    }
                else { ask target as group {do disaggregate ;} }
                }
            }
        }
        
        <span class="hljs-comment">//Reflex to chase a target agent </span>
        reflex chase_target when: (target != <span class="hljs-literal">nil</span>) {
            int direction_to_nearest_ball &lt;- (self towards (target)) ;
            float step_distance &lt;- speed * step ;
            float dx &lt;- step_distance * (cos (direction_to_nearest_ball)) ;
            float dy &lt;- step_distance * (sin (direction_to_nearest_ball)) ;
            geometry envelope &lt;- shape.envelope ;
            point topleft_point &lt;- (envelope.points) at 0 ;
            point bottomright_point &lt;- (envelope.points) at 0 ;
            
            loop p over: envelope.points {
                if ( (p.x &lt;= topleft_point.x) and (p.y &lt;= topleft_point.y) ) {
                    topleft_point &lt;- p ;
                }
                
                if ( (p.x &gt;= bottomright_point.x) and (p.y &gt;= bottomright_point.y) ) {
                    bottomright_point &lt;- p ;
                }
            }
            
            if ( (dx + topleft_point.x) &lt; 0 ) {
                float tmp_dx &lt;- dx + topleft_point.x ;
                dx &lt;- dx - tmp_dx ;
            } else {
                if (dx + bottomright_point.x) &gt; (environment_bounds.x) {
                    float tmp_dx &lt;- (dx + bottomright_point.x) - environment_bounds.x ;
                    dx &lt;- dx - tmp_dx ;
                }
            }
            
            if (dy + topleft_point.y) &lt; 0 {
                float tmp_dy &lt;- dy + topleft_point.y ;
                dy &lt;- dy - tmp_dy ;
            } else {
                if (dy + topleft_point.y) &gt; (environment_bounds.y) {
                    float tmp_dy &lt;- (dy + bottomright_point.y) - (environment_bounds.y) ;
                    dy &lt;- dy - tmp_dy ;
                }
            }
            
            loop com over: (list (ball_in_group)) {
                (ball_in_group (com)).location &lt;- (ball_in_group (com)).location + {dx, dy} ;
            }
            
            shape &lt;- convex_hull((polygon ((list (ball_in_group)) collect (ball_in_group (each)).location)) + 2.0) ;
        }
        <span class="hljs-comment">//Reflex to disaggregate the group if it is too important ie the number of balls is greater than 80% of the total ball number</span>
        reflex self_disaggregate {
            if ( ( length (members) ) &gt; ( 0.8 * (ball_number) ) ) {
                do disaggregate ;
            }
        }
        
        aspect default {
            draw shape color: color;
        }
    }
    
    <span class="hljs-comment">//Species cloud that will be created by an agglomeration of groups.</span>
    species cloud parent: base {
        geometry shape &lt;- convex_hull(polygon(members collect (((group_delegation(each)).shape).location))) update: convex_hull(polygon(members collect (((group_delegation(each)).shape).location)));

        rgb color;
        
        <span class="hljs-comment">//Species contained in the cloud to represent the groups captured by the cloud agent</span>
        species group_delegation parent: group topology: (topology(world.shape)) {
            geometry shape &lt;- convex_hull( (polygon ( (list (ball_in_cloud)) collect (each.location) )) ) buffer 10 update: convex_hull( (polygon ( (list (ball_in_cloud)) collect (each.location) )) ) buffer  10 ;

            reflex capture_nearby_free_balls when: false {
            }
            
            reflex merge_nearby_groups when: false {
            }
            
            reflex chase_target when: false {
            }
            
            reflex self_disaggregate {
            }
            
            action move2 (float with_heading, float with_speed) {

                loop m over: members {
                    ask m as ball_in_cloud {
                        do move2 (with_heading,with_speed);
                    }
                }
            }
             
            species ball_in_cloud parent: ball_in_group topology: (world.shape) as topology control: fsm {
                
                action move2 (float with_heading, float with_speed) {
                    float dx &lt;- cos(with_heading) * with_speed;
                    float dy &lt;- sin(with_heading) * with_speed;
                    location &lt;- { ( (location.x) + dx ), ( (location.y) + dy )};
                }
                
                aspect default {}               
            }
        }
        
        group target_group;
    
        <span class="hljs-comment">//The cloud try to look for small groups to capture them</span>
        reflex chase_group {
            if ( (target_group = <span class="hljs-literal">nil</span>) or (dead(target_group)) ) {
                target_group &lt;- one_of(group);
            }
            
            if (target_group != <span class="hljs-literal">nil</span>) {
                int direction_target &lt;- self towards(target_group);
                
                loop m over: members {
                    ask m as group_delegation {
                        do move2 with: [ with_heading :: float(direction_target), with_speed :: float(cloud_speed) ];
                    }               
                }
            }
        }
        
        <span class="hljs-comment">//Operator to know if a cloud can capture a group overlapping the cloud agent. </span>
        bool can_capture (group a_group) {
            
            if (shape overlaps a_group.shape) { return true; }
            
            loop gd over: members {
                if ( (a_group.shape) overlaps ( ( group_delegation(gd)).shape ) ) { return true; }
            }
            
            return false;
        }
        
        <span class="hljs-comment">//Reflex to capture group</span>
        reflex capture_group {
            if ( (target_group != <span class="hljs-literal">nil</span>) and !(dead(target_group)) ) {
                if (self can_capture [ a_group :: target_group]) {

                    capture target_group as: group_delegation returns: gds;
    
                    ask (gds at 0) as: group_delegation {
                        migrate ball_in_group target: ball_in_cloud;
                    }
                }
            }
        }
        
        <span class="hljs-comment">//Reflex to disaggregate the clouds when they are no more group to capture</span>
        reflex disaggregate when: (empty(list(group))) {
            loop m over: members {
                ask group_delegation(m) as: group_delegation {
                    migrate ball_in_cloud target: ball_in_group;
                }
            }
            
            release members as: group in: world returns: r_groups;
            
            loop rg over: r_groups {
                ask rg as: group { do disaggregate; }
            }
            
            do die; 
        }
         
        aspect default {
            draw shape color: color empty: true;
            draw (name + <span class="hljs-string">' with '</span> + (string(length(members))) + <span class="hljs-string">' groups.'</span>) size: 15 color: color  at: {location.x - 65, location.y};
        }
    }
    
    species group_agents_viewer  { 
        aspect default {
            draw (<span class="hljs-string">'Number of groups: '</span> + (string (length (world.agents of_generic_species group)))) at: {(environment_bounds.x)/2 - 210, (environment_bounds.y)/2} color: #blue size: 40  ;
        }
    }

    species cloud_agents_viewer  { 
        aspect default {
            draw (<span class="hljs-string">'Number of clouds: '</span> + (string (length (list(cloud))))) at: {(environment_bounds.x)/2 - 210, (environment_bounds.y)/2} color: #green size: 40 ;
        }
    } 


experiment group_experiment type: gui {
    parameter <span class="hljs-string">'Create groups?'</span> var: create_group &lt;- true;
    parameter <span class="hljs-string">'Create clouds?'</span> var: create_cloud &lt;- false;
        
    output {
        display <span class="hljs-string">'Standard display'</span> {
            species ball aspect: default transparency: 0.5 ;
            
            species group aspect: default transparency: 0.5 {
                species ball_in_group;
            }
        }
        
        display <span class="hljs-string">'Ball display'</span> {
            species ball;
        }
        
        display <span class="hljs-string">'Group display'</span> {
            species group;
            species group_agents_viewer;
        }
    }
}

experiment cloud_experiment type: gui {

    parameter <span class="hljs-string">'Create groups?'</span> var: create_group &lt;- true;
    parameter <span class="hljs-string">'Create clouds?'</span> var: create_cloud &lt;- true;
        
    output {
        display <span class="hljs-string">'Standard display'</span> {
            species ball aspect: default transparency: 0.5 ;
            
            species group aspect: default transparency: 0.5 {
                species ball_in_group;
            }
            
            species cloud aspect: default {
                species group_delegation transparency: 0.9 {
                    species ball_in_cloud;
                    species ball_in_group;
                }
            }
        }
        
        display <span class="hljs-string">'Ball display'</span> {
            species ball;
        }
        
        display <span class="hljs-string">'Group display'</span> {
            species group;
            species group_agents_viewer;
        }

        display <span class="hljs-string">'Cloud display'</span> {
            species cloud;
        }
        
        monitor <span class="hljs-string">"Balls"</span> value: length(ball);
        monitor <span class="hljs-string">"Groups"</span> value: length(group);
        monitor <span class="hljs-string">"Clouds"</span> value: length(cloud);
    }
}

</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/BC2019-Gama-Site/" class="nav-home"><img src="/BC2019-Gama-Site//img/gama-logo.png" alt="GAMA-Platform" width="66" height="58"/></a><div><h5>Networks</h5><a href="https://www.youtube.com/channel/UCWJ1kWGDDI-9u2f2uD0gcaQ" target="_blank"><i class="fab fa-youtube"></i> Youtube</a><a href="https://www.linkedin.com/company/gama-platform" target="_blank"><i class="fab fa-linkedin"></i> LinkedIn</a><a href="https://twitter.com/gamaplatform" target="_blank"><i class="fab fa-twitter"></i> Twitter</a><a href="https://www.facebook.com/GamaPlatform/" target="_blank"><i class="fab fa-facebook"></i> Facebook</a></div><div><h5>Mailing list</h5><a href="https://groups.google.com/forum/#!forum/gama-platform" target="_blank"><i class="fas fa-envelope"></i> For Users<br/>gama-platform@googlegroups.com</a><a href="https://groups.google.com/forum/#!forum/gama-dev" target="_blank"><i class="fas fa-envelope"></i> For Developers<br/>gama-dev@googlegroups.com</a></div><div><h5>Ecosystem</h5><a href="https://github.com/gama-platform/gama"><i class="fab fa-github"></i> GitHub Gama</a><a href="https://github.com/gama-platform/gama.experimental"><i class="fas fa-puzzle-piece"></i> Gama Experimental Plugins</a><a href="https://github.com/gama-platform/gama.models.experimental"><i class="fas fa-scroll"></i> Gama Experimental Models</a></div></section><section class="copyright">Copyright © 2019 GAMA-Platform</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0f9f28b9ab9efae89810921a351753b5',
                indexName: 'github',
                inputSelector: '#search_input_react'
              });
            </script></body></html>