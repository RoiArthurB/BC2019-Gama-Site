<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Co-model Usage comodel_mix_behaviors · GAMA-Platform</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="GAMA, modeling made easy"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Co-model Usage comodel_mix_behaviors · GAMA-Platform"/><meta property="og:type" content="website"/><meta property="og:url" content="https://roiarthurb.github.io/BC2019-Gama-Site/"/><meta property="og:description" content="GAMA, modeling made easy"/><meta property="og:image" content="https://roiarthurb.github.io/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://roiarthurb.github.io/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><link rel="shortcut icon" href="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/atom.xml" title="GAMA-Platform Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/feed.xml" title="GAMA-Platform Blog RSS Feed"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js" async=""></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js" async=""></script><script type="text/javascript" src="/BC2019-Gama-Site/js/code-block-buttons.js" async=""></script><link rel="stylesheet" href="/BC2019-Gama-Site/css/main.css"/><script src="/BC2019-Gama-Site/js/codetabs.js"></script></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/BC2019-Gama-Site/"><img class="logo" src="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png" alt="GAMA-Platform"/><h2 class="headerTitleWithLogo">GAMA-Platform</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/BC2019-Gama-Site/docs/Home" target="_self">Docs</a></li><li class=""><a href="/BC2019-Gama-Site/help" target="_self">Help</a></li><li class=""><a href="/BC2019-Gama-Site/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Co-model Usage comodel_mix_behaviors</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="comodel-with-mixed-behaviors"></a><a href="#comodel-with-mixed-behaviors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>comodel with mixed behaviors</h1>
<p><em>Author : HUYNH Quang Nghi</em></p>
<p>This is a simple comodel serve to demonstrate the mixing behaviors of preyPredator with the Ants. Ants are the prey, fleeing from Predators, when they are not chasing, they try to do job of the ants.</p>
<p>Imported models :</p>
<pre><code class="hljs">model ants

global {
    //Evaporation value per cycle
    float evaporation_per_cycle &lt;- 5.0 min: 0.0 max: 240.0 parameter: 'Evaporation of the signal (unit/cycle):' category: 'Signals';
    //Diffusion rate of the pheromon among the grid
    float diffusion_rate &lt;- 1.0 min: 0.0 max: 1.0 parameter: 'Rate of diffusion of the signal (%/cycle):' category: 'Signals';
    //Size of the grid
    int gridsize &lt;- 100 min: 30 parameter: 'Width and Height of the grid:' category: 'Environment and Population';
    //Number of ants
    int ants_number &lt;- 200 min: 1 parameter: 'Number of ants:' category: 'Environment and Population';
    //Frequency of update of the grid
    int grid_frequency &lt;- 1 min: 1 max: 100 parameter: 'Grid updates itself every:' category: 'Environment and Population';
    //Number of food places among the grid
    int number_of_food_places &lt;- 5 min: 1 parameter: 'Number of food depots:' category: 'Environment and Population';
    float grid_transparency &lt;- 1.0;
    file ant_shape_empty const: true &lt;- file('../icons/ant.png');
    image_file ant_shape_full const: true &lt;- file('../icons/full_ant.png');
    //The center of the grid that will be considered as the nest location
    point center const: true &lt;- { round(gridsize / 2), round(gridsize / 2) };
    int food_gathered &lt;- 1;
    int food_placed &lt;- 1;
    rgb background const: true &lt;- rgb(#99CC66);
    rgb food_color const: true &lt;- rgb(#312200);
    rgb nest_color const: true &lt;- rgb(#000000); 

    geometry shape &lt;- square(gridsize);
    init {
        //Creation of the food places placed randomly with a certain distance between each
        loop times: number_of_food_places {
            point loc &lt;- { rnd(gridsize - 10) + 5, rnd(gridsize - 10) + 5 };
            list&lt;ant_grid&gt; food_places &lt;- (ant_grid where ((each distance_to loc) &lt; 5));
            ask food_places {
                if food = 0 {
                    food &lt;- 5;
                    food_placed &lt;- food_placed + 5;
                    color &lt;- food_color;  
                }                                           
            }
        }
        //Creation of the ants that will be placed in the nest
        create ant number: ants_number with: (location: center);
    }
    //Reflex to diffuse the pheromon among the grid
    reflex diffuse {
      diffuse var:road on:ant_grid proportion: diffusion_rate radius:3 propagation: gradient method:convolution;
   }
  
}

//Grid used to discretize the space to place food
grid ant_grid width: gridsize height: gridsize neighbors: 8 frequency: grid_frequency use_regular_agents: false use_individual_shapes: false{
    bool is_nest const: true &lt;- (topology(ant_grid) distance_between [self, center]) &lt; 4;
    float road &lt;- 0.0 max: 240.0 update: (road &lt;= evaporation_per_cycle) ? 0.0 : road - evaporation_per_cycle;
    rgb color &lt;- is_nest ? nest_color : ((food &gt; 0) ? food_color : ((road &lt; 0.001) ? background : rgb(#009900) + int(road * 5))) update: is_nest ? nest_color : ((food &gt; 0) ?
    food_color : ((road &lt; 0.001) ? background : rgb(#009900) + int(road * 5)));
    int food &lt;- 0;
}
//Species ant that will move and follow a final state machine
species ant skills: [moving] control: fsm {
    float speed &lt;- 1.0;
    bool has_food &lt;- false;
    
    //Reflex to place a pheromon stock in the cell
    reflex diffuse_road when:has_food=true{
      ant_grid(location).road &lt;- ant_grid(location).road + 100.0;
   }
    //Action to pick food
    action pick (int amount) {
        has_food &lt;- true;
        ant_grid place &lt;- ant_grid(location);
        place.food &lt;- place.food - amount;
    }
    //Action to drop food
    action drop {
        food_gathered &lt;- food_gathered + 1;
        has_food &lt;- false;
        heading &lt;- heading - 180;
    }
    //Action to find the best place in the neighborhood cells
    point choose_best_place {
        container list_places &lt;- ant_grid(location).neighbors;
        if (list_places count (each.food &gt; 0)) &gt; 0 {
            return point(list_places first_with (each.food &gt; 0));
        } else {
            list_places &lt;- (list_places where ((each.road &gt; 0) and ((each distance_to center) &gt; (self distance_to center)))) sort_by (each.road);
            return point(last(list_places));
        }

    }
    //Reflex to drop food once the ant is in the nest
    reflex drop when: has_food and (ant_grid(location)).is_nest {
        do drop();
    }
    //Reflex to pick food when there is one at the same location
    reflex pick when: !has_food and (ant_grid(location)).food &gt; 0 {
        do pick(1);
    }
    //Initial state to make the ant wander 
    state wandering initial: true {
        do wander(amplitude: 90);
        float pr &lt;- (ant_grid(location)).road;
        transition to: carryingFood when: has_food;
        transition to: followingRoad when: (pr &gt; 0.05) and (pr &lt; 4);
    }
    //State to carry food once it has been found
    state carryingFood {
        do goto(target: center);
        transition to: wandering when: !has_food;
    }
    //State to follow a pheromon road if once has been found
    state followingRoad {
        point next_place &lt;- choose_best_place();
        float pr &lt;- (ant_grid(location)).road;
        location &lt;- next_place;
        transition to: carryingFood when: has_food;
        transition to: wandering when: (pr &lt; 0.05) or (next_place = nil);
    }

    aspect info {
        draw circle(1) empty: !has_food color: #red;
        if (destination != nil) {
            draw line([location + {0,0,0.5}, destination + {0,0,0.5}]) + 0.1 color: #white border: false;
        }

        draw circle(4) empty: true color: #white;
        draw string(self as int) color: #white font: font("Helvetica", 12 * #zoom, #bold) at: my location - {1, 1, -0.5};
        draw state color: #yellow  font: font("Helvetica", 10 * #zoom, #plain) at: my location + { 1, 1, 0.5 } perspective: false;
    }

    aspect icon {
        draw ant_shape_empty size: {7,5} rotate: my heading + 1;
    }

    aspect default {
        draw square(1) empty: !has_food color: #blue rotate: my heading;
    }
}   
//Simple experiment to display the ants
experiment Displays type: gui {
    point quadrant_size &lt;- { 0.5, 0.5 };
    float inc &lt;- 0.001;
    float pos &lt;- 0.0;
    reflex moving_quadrant {
    //pos &lt;- pos + inc;
        if (pos &gt; 0.5 or pos &lt;= 0) {
            inc &lt;- -inc;
        }
        
    }

    output {
        display Ants background: #white type: opengl {
            image '../images/soil.jpg' position: { pos, pos } size: quadrant_size;
            agents "agents" transparency: 0.5 position: { pos, pos } size: quadrant_size value: (ant_grid as list) where ((each.food &gt; 0) or (each.road &gt; 0) or (each.is_nest));
            species ant position: { pos, pos } size: quadrant_size aspect: icon;
            grid ant_grid lines: #darkgray position: { 0.5, 0 } size: quadrant_size;
            species ant position: { 0.5, 0 } size: quadrant_size aspect: info;
        }
    }
}
//Complete experiment that will inspect all ants in a table
experiment Complete type: gui {
    parameter 'Number:' var: ants_number init: 100 unit: 'ants' category: 'Environment and Population';
    parameter 'Grid dimension:' var: gridsize init: 100 unit: '(number of rows and columns)' category: 'Environment and Population';
    parameter 'Number of food depots:' var: number_of_food_places init: 5 min: 1 category: 'Environment and Population';

    // Experimentator

    init {
        write "Experimentator agent running " + self;
       ants_number &lt;- 200;
    }


    output {
        display Ants2D type: java2D {
            image '../images/soil.jpg' position: { 0.05, 0.05 } size: { 0.9, 0.9 };
            agents "agents" transparency: 0.7 position: { 0.05, 0.05 } size: { 0.9, 0.9 } value: (ant_grid as list) where ((each.food &gt; 0) or (each.road &gt; 0) or (each.is_nest)) ;
            species ant position: { 0.05, 0.05 } size: { 0.9, 0.9 } aspect: icon;
            overlay "Texts" transparency: 0.3 background: rgb (99, 85, 66,255)  position: {10°px, 10°px} size: {250°px, 150°px} border: rgb (99, 85, 66,255) rounded: true{
                draw ant_shape_full at: {60°px, 70°px} size: {140°px, 100°px} rotate: -60;
                draw ('Food foraged: ' + (((food_placed = 0 ? 0 : food_gathered / food_placed) * 100) with_precision 2) + '%') at: {40°px,70°px} font:font("Arial", 18, #bold) color: #white;
                draw ('Carrying ants: ' + (((100 * ant count (each.has_food or each.state = "followingRoad")) / length(ant)) with_precision 2) + '%') at: {40°px, 100°px} font:font("Arial", 18 , #bold) color: #white;
            }
                    
        }
        inspect "All ants" type: table value: ant attributes: ['name', 'location', 'heading','state'];
    }
}
//Batch experiment to find the best way to maximize the food gathered using exhaustive method
experiment Batch type: batch repeat: 4 keep_seed: true until: (food_gathered = food_placed) or (time &gt; 1000) {
    parameter 'Size of the grid:' var: gridsize init: 75 unit: 'width and height';
    parameter 'Number:' var: ants_number among:[10,20,50] unit: 'ants';
    parameter  'Evaporation:' var: evaporation_per_cycle among: [0.1, 0.5, 2.0, 10.0] unit: 'units every cycle';
    parameter  'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.2;
    method exhaustive maximize: food_gathered;

    
    permanent {
        display Comparison background: #white {
            chart "Food Gathered" type: series {
                    data "Min" value:  min(ants_model collect each.food_gathered ) style: spline color: #darkgreen ;
                    data "Max" value:  max(ants_model collect each.food_gathered ) style: spline color: #red ;
            }
        }
    }
}

//Batch experiment to find the best way to maximize the food gathered using genetic method
experiment Genetic type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed) or (time &gt; 1000) {
    parameter 'Size of the grid:' var: gridsize init: 75 unit: '(width and height)';
    parameter 'Number:' var: ants_number among:[10,20,50] unit: 'ants';
    parameter  'Evaporation:' var: evaporation_per_cycle among: [0.1, 0.5, 2.0, 10.0] unit: 'units every cycle';
    parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.2;
    method genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20;
    
        permanent {
        display Comparison background: #white {
            chart "Food Gathered" type: series {
                    data "Min" value:  min(ants_model collect each.food_gathered ) style: spline color: #darkgreen ;
                    data "Max" value:  max(ants_model collect each.food_gathered ) style: spline color: #red ;
            }
        }
    }
}

</code></pre>
<pre><code class="hljs">model Ants_coupling

<span class="hljs-keyword">import</span> <span class="hljs-string">"../../../Toy Models/Ants (Foraging and Sorting)/models/Ant Foraging (Complex).gaml"</span> 



experiment Ants_coupling_exp type:gui  parent:Complete{
    
    list&lt;ant&gt; getAnts{
        <span class="hljs-keyword">return</span> list(ant);
    }
    
    list&lt;ant_grid&gt; getAnt_grid{
        <span class="hljs-keyword">return</span> list(ant_grid);
    }
    
    output{ 
    }
}
</code></pre>
<pre><code class="hljs">model PreyPredator
 global
{
    geometry shape &lt;- square(100);
    float perceipt_radius &lt;- 20.0;
    int preyinit &lt;- 500;
    int predatorinit &lt;- 3;
    list&lt;agent&gt; lstPredator &lt;- list&lt;agent&gt;(predator);
    list&lt;agent&gt; lstPrey &lt;- list&lt;agent&gt;(prey);
    init
    {
        create prey number: preyinit;
        create predator number: predatorinit;
        lstPredator &lt;- list&lt;agent&gt;(predator);
        lstPrey &lt;- list&lt;agent&gt;(prey);
    }

}

species generic_species skills: [moving]
{
    float speed &lt;- 1.0;
    point goal &lt;- nil;
    bool is_chased &lt;- false;
    reflex live_with_my_goal
    {
        if (goal != nil)
        {
            do wander speed: speed;
            do goto target: goal speed: speed;
        } else
        {
            do wander speed: speed;
        }

    }

}

species prey parent: generic_species
{
    geometry shape &lt;- circle(0.5);
    float speed &lt;- 0.2;
    rgb color &lt;- # green;
    reflex fleeing
    {
        if (length((lstPredator where (each != nil and !dead(each) and each distance_to self &lt; perceipt_radius))) &gt; 0)
        {
            speed &lt;- 1.0;
            is_chased &lt;- true;
            color &lt;- # lime;
            if (goal = nil)
            {
                agent a &lt;- any(((lstPrey where (each != nil and !dead(each) and !generic_species(each).is_chased))));
                if (a != nil and !dead(a))
                {
                    if (flip(0.5))
                    {
                        goal &lt;- a.location;
                    } else
                    {
                        goal &lt;- any_location_in(world.shape);
                    }

                } else
                {
                    goal &lt;- any_location_in(world.shape);
                }

            }

        }

        if (goal != nil and self.location distance_to goal &lt; 0.5)
        {
            goal &lt;- nil;
        }

        if (length((lstPredator where (each != nil and !dead(each))) where (each distance_to self &lt;= perceipt_radius)) = 0)
        {
            is_chased &lt;- false;
            color &lt;- # green;
            speed &lt;- 0.2;
        }

    }

    aspect default
    {
        draw shape color: color;
    }

}

species predator parent: generic_species
{
    geometry shape &lt;- triangle(2);
    rgb color &lt;- # red;
    reflex hunting
    {
        if (goal = nil)
        {
            list tmp &lt;- (lstPrey where (!dead(each) and each.shape distance_to self.shape &lt; perceipt_radius));
            if (length(tmp) &gt; 0)
            {
                agent a &lt;- first(tmp sort (each.shape distance_to self.shape));
                if (a = nil)
                {
                    a &lt;- any((lstPrey where (!dead(each))));
                }

                if (a != nil)
                {
                    speed &lt;- 2.0;
                    goal &lt;- a.location;
                }

            }

        } else if ((self.location distance_to goal &lt; 0.5))
        {
            ask lstPrey where (!dead(each) and each.location distance_to goal &lt; 0.5)
            {
                do die;
            }

            goal &lt;- nil;
            speed &lt;- 1.0;
        }

    }

    aspect default
    {
        draw circle(perceipt_radius) color: # pink empty: true;
        draw shape color: color rotate: 90 + my heading;
    }

}

experiment prey_predator_exp type: gui
{
    output
    {
        display main_display

        {
            species prey;
            species predator;
        }

    }

}
</code></pre>
<pre><code class="hljs">model PreyPredator_coupling
<span class="hljs-keyword">import</span> <span class="hljs-string">"PreyPredator.gaml"</span>

global
{   
}

experiment PreyPredator_coupling_exp parent:prey_predator_exp type: gui
{
geometry shape&lt;- square(<span class="hljs-number">100</span>);
    list&lt;prey&gt; getPrey{
        <span class="hljs-keyword">return</span> list(prey);
    }
        list&lt;predator&gt; getPredator{
        <span class="hljs-keyword">return</span> list(predator);
    }
    
    <span class="hljs-comment">//if we redefine the output, i.e, a blank output, the displays in parent experiement dont show.</span>
    output
    {
    }

}


</code></pre>
<p>Code of the model :</p>
<pre><code class="hljs">model comodel_mix_behaviors

<span class="hljs-keyword">import</span> <span class="hljs-string">"PreyPredator_coupling.gaml"</span> <span class="hljs-keyword">as</span> myPreyPredator
<span class="hljs-keyword">import</span> <span class="hljs-string">"Ants_coupling.gaml"</span> <span class="hljs-keyword">as</span> myAnt


global
{
    <span class="hljs-comment">//set the shape of environment: square 100 </span>
    geometry shape &lt;- square(<span class="hljs-number">100</span>);
    <span class="hljs-comment">// the variable that refer to the ants population in micro-model </span>
    list&lt;agent&gt; theAnts;
    <span class="hljs-comment">// the variable that refer to the prey population in micro-model</span>
    list&lt;prey&gt; thePreys;
    
    init
    {
        <span class="hljs-comment">//create the Ants micro-model with the size of grid is 100 and the population have 500 ants.</span>
        create myAnt.Ants_coupling_exp <span class="hljs-keyword">with</span>: [gridsize::<span class="hljs-number">100</span>,<span class="hljs-attr">ants_number</span>::<span class="hljs-number">500</span>];
        <span class="hljs-comment">//create the PreyPredator micro-model with the parameters and the number of the prey is equal with the size of ants population</span>
        create myPreyPredator.PreyPredator_coupling_exp <span class="hljs-keyword">with</span>: [shape::square(<span class="hljs-number">100</span>), <span class="hljs-attr">preyinit</span>::myAnt.Ants_coupling_exp[<span class="hljs-number">0</span>].simulation.ants_number, <span class="hljs-attr">predatorinit</span>::<span class="hljs-number">3</span>]  
        {
            <span class="hljs-comment">// set the size of micro-model PreyPredator equal with the size of the grid of myAnt</span>
            shape &lt;- square(<span class="hljs-number">100</span>);
        }

        <span class="hljs-comment">// save the original population of the Ants and the Preys</span>
        theAnts &lt;- myAnt.Ants_coupling_exp accumulate each.getAnts();
        thePreys &lt;- list&lt;prey&gt;(myPreyPredator.PreyPredator_coupling_exp accumulate each.getPrey());


    }

    reflex simulate_micro_models
    {
        <span class="hljs-comment">// ask myAnt do a step</span>
        ask (myAnt.Ants_coupling_exp collect each.simulation)
        {
            <span class="hljs-keyword">do</span> _step_;
        }
        <span class="hljs-comment">// ask myPreyPredator do a step, too</span>
        ask (myPreyPredator.PreyPredator_coupling_exp collect each.simulation)
        {
            <span class="hljs-keyword">do</span> _step_;
        }

        <span class="hljs-comment">//check if a Prey is chased, set the position of that agent to the location of prey </span>
        <span class="hljs-comment">//if not, set ant's location to agent location.</span>
        <span class="hljs-comment">// if the agent (prey) died, then tell the ant do die</span>
        loop i <span class="hljs-keyword">from</span>: <span class="hljs-number">0</span> to: length(theAnts) - <span class="hljs-number">1</span>
        {
            <span class="hljs-keyword">if</span> (!dead(thePreys at i) and !dead(theAnts at i))
            {
                <span class="hljs-keyword">if</span> (!(thePreys at i).is_chased)
                {
                    (thePreys at i).location &lt;- (theAnts at i).location;
                } <span class="hljs-keyword">else</span>
                {
                    (theAnts at i).location &lt;- (thePreys at i).location;
                }

            } <span class="hljs-keyword">else</span>
            {
                ask (theAnts at i)
                {
                    <span class="hljs-keyword">do</span> die;
                }

            }

        }

    }

}

experiment comodel_mix_behaviors_exp type: gui
{
    output
    {
        display <span class="hljs-string">"comodel"</span>
        {
            agents <span class="hljs-string">"ant_grid"</span> value: myAnt.Ants_coupling_exp accumulate each.getAnt_grid() transparency: <span class="hljs-number">0.7</span>;
            agents <span class="hljs-string">"agentprey"</span> value: (myPreyPredator.PreyPredator_coupling_exp accumulate each.getPrey());
            agents <span class="hljs-string">"agentpredator"</span> value: (myPreyPredator.PreyPredator_coupling_exp accumulate each.getPredator());
        }

    }

}
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/BC2019-Gama-Site/" class="nav-home"><img src="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png" alt="GAMA-Platform" width="66" height="58"/></a><div><h5>Docs</h5><a href="/BC2019-Gama-Site/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/BC2019-Gama-Site/docs/en/doc2.html">Guides (or other categories)</a><a href="/BC2019-Gama-Site/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/BC2019-Gama-Site/en/users.html">User Showcase</a><a href="http://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/BC2019-Gama-Site/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2019 GAMA-Platform</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0f9f28b9ab9efae89810921a351753b5',
                indexName: 'github',
                inputSelector: '#search_input_react'
              });
            </script></body></html>