<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Corridor Multi-Level Architecture · GAMA-Platform</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="GAMA, modeling made easy"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Corridor Multi-Level Architecture · GAMA-Platform"/><meta property="og:type" content="website"/><meta property="og:url" content="https://roiarthurb.github.io/BC2019-Gama-Site/"/><meta property="og:description" content="GAMA, modeling made easy"/><meta property="og:image" content="https://roiarthurb.github.io/BC2019-Gama-Site//resources/images/general/GamaPlatform.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://roiarthurb.github.io/BC2019-Gama-Site//resources/images/general/GamaPlatform.png"/><link rel="shortcut icon" href="/BC2019-Gama-Site//resources/images/general/GamaPlatform.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/atom.xml" title="GAMA-Platform Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/feed.xml" title="GAMA-Platform Blog RSS Feed"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js" async=""></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js" async=""></script><script type="text/javascript" src="/BC2019-Gama-Site/js/code-block-buttons.js" async=""></script><link rel="stylesheet" href="/BC2019-Gama-Site/css/main.css"/><script src="/BC2019-Gama-Site/js/codetabs.js"></script></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/BC2019-Gama-Site/"><img class="logo" src="/BC2019-Gama-Site//resources/images/general/GamaPlatform.png" alt="GAMA-Platform"/><h2 class="headerTitleWithLogo">GAMA-Platform</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/BC2019-Gama-Site/docs/Home" target="_self">Documentation</a></li><li class=""><a href="/BC2019-Gama-Site/docs/Tutorials" target="_self">Tutorials</a></li><li class=""><a href="/BC2019-Gama-Site/help" target="_self">Download</a></li><li class=""><a href="/BC2019-Gama-Site/help" target="_self">Contribute</a></li><li class=""><a href="/BC2019-Gama-Site/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Corridor Multi-Level Architecture</h1></header><article><div><span><p>_Author : _</p>
<p>This model shows how to use multi-level architecture. A corridor can capture pedestrians going from left to right side if they are inside the corridor. This will result in changing their species from pedestrian to captured_pedestrian which will not be displayed. Once they pass enought time to consider they reach the exit of the corridor, they will be released by the corridor agent as pedestrians, letting them been displayed and going to their target.</p>
<p>Code of the model :</p>
<pre><code class="hljs">
model corridor

global {    
    <span class="hljs-comment">//Capture pedestrians parameter to define if wall will capture pedestrians</span>
    bool capture_pedestrians &lt;- false parameter: <span class="hljs-string">'Capture pedestrians?'</span>;
    
    int environment_size init: 2000;
    point environment_bounds init: {environment_size, environment_size} ;
    geometry shape &lt;- rectangle(environment_bounds) ;       
    
    <span class="hljs-comment">//Pedestrians parameters</span>
    float pedestrian_size init: 1.0;
    geometry pedestrian_shape &lt;- circle (pedestrian_size);
    rgb pedestrian_color &lt;- #green; 
    float pedestrian_speed &lt;- 2.0;
    
    
    <span class="hljs-comment">//Wall parameters</span>
    rgb corridor_wall_color &lt;- #black;
    int corridor_wall_width &lt;- int(environment_size / 2);
    int corridor_wall_height &lt;- 200;
    geometry corridor_wall_0_shape &lt;- rectangle ( {corridor_wall_width, corridor_wall_height} ) at_location {environment_size / 2, corridor_wall_height / 2};
    geometry corridor_wall_1_shape &lt;- rectangle ( {corridor_wall_width, corridor_wall_height} ) at_location {environment_size / 2, environment_size - (corridor_wall_height / 2)};
    
    <span class="hljs-comment">//Corridor parameters</span>
    rgb corridor_color &lt;- #blue;
    int corridor_width &lt;- int(environment_size / 2) ;
    int corridor_height &lt;- environment_size ;
    point corridor_location &lt;- {environment_size / 2, environment_size / 2} ;
    geometry corridor_shape &lt;- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location) - (corridor_wall_0_shape + corridor_wall_1_shape);
    int corridor_left_bounds &lt;- (int(corridor_location.x - (corridor_width / 2))) ;
    int corridor_right_bounds &lt;- (int(corridor_location.x + (corridor_width / 2))) ;
    
    <span class="hljs-comment">//Generation of new pedestrians parameters</span>
    int new_pedestrian_rate &lt;- 10;
    int new_pedestian_generate_frequency &lt;- 1;
    int new_pedestrian_y_distance &lt;- int(environment_size / new_pedestrian_rate);
    
    list&lt;pedestrian&gt; pedestrians  update: list(pedestrian); 
    float start_time &lt;- machine_time;
    
    init {
        create corridor;
         
        create corridor_wall number: 2 returns: corridor_walls; 
        (corridor_walls at 0).shape &lt;- corridor_wall_0_shape;
        (corridor_walls at 1).shape &lt;- corridor_wall_1_shape;
        
    }
    
    <span class="hljs-comment">//Reflex to generate new pedestrians according to the frequency generation parameter</span>
    reflex generate_pedestrians when: ((cycle mod new_pedestian_generate_frequency) = 0) {
        create pedestrian number: new_pedestrian_rate returns: new_pedestrians; 
        
        int loop_times &lt;- 0;
        loop p over: new_pedestrians {
            int y_coor &lt;- rnd (new_pedestrian_y_distance);
            ask p as: pedestrian {
                do init_location loc: { 0, (loop_times * new_pedestrian_y_distance) + y_coor };
            }
            loop_times &lt;- loop_times + 1;
        }
    }

} 

<span class="hljs-comment">//Species pedestrian which will move from one side of the experiments to another and destroy itself once the other side is reached</span>
species pedestrian skills: [moving] topology: ( topology (shape - (corridor_wall_0_shape + corridor_wall_1_shape)) ){
    geometry shape &lt;-  circle (pedestrian_size);
    point initial_location;
    point target_location;
    int heading;
    float speed &lt;- 2.0;
    
    action init_location (point loc) {
        location &lt;- loc;
        initial_location &lt;- loc;
        target_location &lt;- {environment_size, loc.y};
        heading &lt;- (self) towards (target_location);
    }
    
    <span class="hljs-comment">//Reflex to make the agent move to its target_location</span>
    reflex move_left {
        int update_heading &lt;- (self) towards (target_location);
        
        point current_location &lt;- location;
        
        do move heading: update_heading ;
        
        <span class="hljs-comment">//Conditions to know if the agent doesn't move, in this case we take care if it is bcause of the walls </span>
        if (current_location = location) {
            if ( (location.y &lt;= corridor_wall_height) or (location.y &gt;= environment_size - corridor_wall_height) ) {
                do move heading: self towards {(environment_size / 2) - (corridor_width / 2), environment_size / 2}; 
            } else {
                do move heading: self towards {environment_size / 2, environment_size / 2}; 
            }
        }
        
        if( (target_location.x - location.x) &lt;= speed ) { 
            do die;
        }
    }
     
    aspect my_aspect {
        draw shape color: pedestrian_color;
    }
}

<span class="hljs-comment">//Species which represents the corridor</span>
species corridor  {
    geometry shape &lt;- corridor_shape;
    
    <span class="hljs-comment">//Subspecies for the multi-level architectures : captured pedestrians in this case</span>
    species captured_pedestrian parent: pedestrian schedules: [] {
        float released_time;
        
        aspect my_aspect { }
    }
    
    init {
        create corridor_info_drawer number: 1 with: [target :: self];
    }
    
    <span class="hljs-comment">//Reflex to capture pedestrians if the parameter is checked</span>
    reflex aggregate when: capture_pedestrians {
        <span class="hljs-comment">//List to get all the pedestrians inside the corridor</span>
        list&lt;pedestrian&gt; tobe_captured_pedestrians &lt;- (pedestrian overlapping shape);
        
        <span class="hljs-comment">//If we have pedestrians inside the corridor, we capture them</span>
        if !(empty (tobe_captured_pedestrians)) {
            capture tobe_captured_pedestrians as: captured_pedestrian returns: cps;
            
            <span class="hljs-comment">//We update the time during which a pedestrian is captured according to the time the pedestrian</span>
            <span class="hljs-comment">// should need to pass through the corridor if it wasn't captured</span>
            loop cp over: cps {
                cp.released_time &lt;- time + ( ( corridor_width - ( (((cp).location).x) - ((environment_size / 2) - (corridor_width / 2)) ) ) / pedestrian_speed) ;
            }
        }
    }
    
    <span class="hljs-comment">//Reflex to release pedestrians which have already passed enough time in the corridor</span>
    <span class="hljs-comment">// which means if they weren't captured by the corridor, they would have finish passing through it</span>
    reflex disaggregate  {
        list tobe_released_pedestrians &lt;- members where (time &gt;= (captured_pedestrian (each)).released_time);
        if !(empty (tobe_released_pedestrians)) {
            release tobe_released_pedestrians as: pedestrian in: world {
                location &lt;- {((environment_size / 2) + (corridor_width / 2)) + (2 * pedestrian_size), (location).y};
            }
        }
    }
    
    aspect my_aspect {
        draw shape color: corridor_color;
    }
}

species corridor_wall {
    init {
        create corridor_wall_info_drawer number: 1 with: [target :: self];
    }
    
    aspect  my_aspect {
        draw shape color: corridor_wall_color;
    }
}

species corridor_info_drawer {
    corridor target;
    
    aspect my_aspect {
        draw  <span class="hljs-string">'Captured pedestrians: '</span> + (string (length (target.members))) color: rgb (<span class="hljs-string">'blue'</span>) size: 12°px at: {(target.location).x - 480, (target.location).y};
        draw  <span class="hljs-string">'Pedestrians: '</span> + (string (length (list (pedestrian)))) color: rgb (<span class="hljs-string">'blue'</span>) size: 12°px at: {(target.location).x - 135, (target.location).y + 100};
    }
}

species corridor_wall_info_drawer {
    corridor_wall target;
    
    init {
        location &lt;- target.location;
    }
    
    aspect my_aspect { 
        draw <span class="hljs-string">'WALL'</span> color: rgb (<span class="hljs-string">'green'</span>) size: 15°px at: {(location).x - 40, (location).y};
    }
}


experiment corridor_expr type: gui{
    output {
        display defaut_display {
            species pedestrian;
            
            species corridor aspect: my_aspect transparency: 0.8 {
                species captured_pedestrian;
            }
            
            species corridor_wall aspect: my_aspect transparency: 0.7;
            species corridor_info_drawer aspect: my_aspect;
            species corridor_wall_info_drawer aspect: my_aspect;
        }

        display Execution_Time refresh: every(25) {
            chart <span class="hljs-string">'Simulation step length'</span> type: series background: #white {
                data <span class="hljs-string">'simulation_step_length_in_mili_second'</span> value: machine_time - start_time color: (rgb (<span class="hljs-string">'green'</span>));
            }
        }
        
        display Captured_Pedestrians refresh: every(25){
            chart <span class="hljs-string">'Captured Pedestrian'</span> type: series background: #white {
                data <span class="hljs-string">'captured_pedestrians'</span> value: length ( ((list (corridor)) at 0).members ) color: rgb (<span class="hljs-string">'blue'</span>);
                data <span class="hljs-string">'pedestrians'</span> value: length (list (pedestrian)) color: rgb (<span class="hljs-string">'white'</span>);  
            }
        }
    }
}
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/BC2019-Gama-Site/" class="nav-home"><img src="/BC2019-Gama-Site//resources/images/general/GamaPlatform.png" alt="GAMA-Platform" width="66" height="58"/></a><div><h5>Networks</h5><a href="https://www.youtube.com/channel/UCWJ1kWGDDI-9u2f2uD0gcaQ" target="_blank"><i class="fab fa-youtube"></i> Youtube</a><a href="https://www.linkedin.com/company/gama-platform" target="_blank"><i class="fab fa-linkedin"></i> LinkedIn</a><a href="https://twitter.com/gamaplatform" target="_blank"><i class="fab fa-twitter"></i> Twitter</a><a href="https://www.facebook.com/GamaPlatform/" target="_blank"><i class="fab fa-facebook"></i> Facebook</a></div><div><h5>Mailing list</h5><a href="https://groups.google.com/forum/#!forum/gama-platform" target="_blank"><i class="fas fa-envelope"></i> For Users<br/>gama-platform@googlegroups.com</a><a href="https://groups.google.com/forum/#!forum/gama-dev" target="_blank"><i class="fas fa-envelope"></i> For Developers<br/>gama-dev@googlegroups.com</a></div><div><h5>Ecosystem</h5><a href="https://github.com/gama-platform/gama"><i class="fab fa-github"></i> GitHub Gama</a><a href="https://github.com/gama-platform/gama.experimental"><i class="fas fa-puzzle-piece"></i> Gama Experimental Plugins</a><a href="https://github.com/gama-platform/gama.models.experimental"><i class="fas fa-scroll"></i> Gama Experimental Models</a></div></section><section class="copyright">Copyright © 2019 GAMA-Platform</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0f9f28b9ab9efae89810921a351753b5',
                indexName: 'github',
                inputSelector: '#search_input_react'
              });
            </script></body></html>