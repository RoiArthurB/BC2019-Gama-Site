<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Traffic LWR Traffic Flow Model · GAMA-Platform</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="GAMA, modeling made easy"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Traffic LWR Traffic Flow Model · GAMA-Platform"/><meta property="og:type" content="website"/><meta property="og:url" content="https://roiarthurb.github.io/BC2019-Gama-Site/"/><meta property="og:description" content="GAMA, modeling made easy"/><meta property="og:image" content="https://roiarthurb.github.io/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://roiarthurb.github.io/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><link rel="shortcut icon" href="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/atom.xml" title="GAMA-Platform Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/feed.xml" title="GAMA-Platform Blog RSS Feed"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js" async=""></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js" async=""></script><script type="text/javascript" src="/BC2019-Gama-Site/js/code-block-buttons.js" async=""></script><link rel="stylesheet" href="/BC2019-Gama-Site/css/main.css"/><script src="/BC2019-Gama-Site/js/codetabs.js"></script></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/BC2019-Gama-Site/"><img class="logo" src="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png" alt="GAMA-Platform"/><h2 class="headerTitleWithLogo">GAMA-Platform</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/BC2019-Gama-Site/docs/Home" target="_self">Docs</a></li><li class=""><a href="/BC2019-Gama-Site/help" target="_self">Help</a></li><li class=""><a href="/BC2019-Gama-Site/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Traffic LWR Traffic Flow Model</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="trafic-group-r2d2-maps7-lwr-model"></a><a href="#trafic-group-r2d2-maps7-lwr-model" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Trafic Group (R2D2) MAPS7 - LWR Model</h1>
<p><em>Author : A. Banos, N. Corson, C. Pivano, L. Rajaonarivo, P. Taillandier</em></p>
<p>The LWR model was proposed by Lighthill and Whitham (1955) and by Richards (1956). It describes the trafic at a global level considering the speed, concentration and flows without taking into account the individual behavior af vehicles. Speed, concentration and flow are the three components of the LWR model. This models reproduces flow of traffic and congestion in specific conditions (homogeneous traffic), going from one equilibrium state to another (see the fundamental diagramm of traffic, which gives flow according to concentration).
In this model, a road is divided into sections and we arbitrarily give to the middle section a lower speed and critical concentration.</p>
<p>Code of the model :</p>
<pre><code class="hljs">

model TraficGroup

global {
        
    float road_size &lt;- 10 #km ;                         // Size of the road
    
    geometry shape &lt;- rectangle (road_size, 200 #m) ;   // The world is a rectangle with a length equals to the size of the road and a height of 200m
        
    float time_step &lt;- 1.0 ;                            // Time step 
    int nb_sections &lt;- 10 ;                             // Number of sections of the road
    float section_size &lt;- road_size / nb_sections ;     // Size of a section
    
    float car_size &lt;- 4 #m ;                                    // Size of a car
    float nb_max_cars_on_section &lt;- section_size / car_size ;   // Maximum number of cars on one section 
    
       init{
            
            // Creation of the nb_sections sections which compose the road. 
            
           loop i from: 0 to: (nb_sections - 1){
              create section with: [shape:: line([{i * section_size , 100},{(i +1) * section_size , 100}])];
           }
            
            // For each section, as we need to have information concerning the previous and the next one, we define which section is the previous and which is the next.
            // The previous section is the one which last point corresponds to the first point of the actual section. 
            // The next section is the one which first point corresponds to the last point of the actual section. 
            
            ask section{
                previous &lt;- section first_with (last(each.shape.points) = first(self.shape.points)) ;
                next &lt;- section first_with (first(each.shape.points) = last(self.shape.points)) ;
            }
    
            // For each section, we define a critical concentration (see the fundamental diagram), a maximum speed, a concentration and a flow (which are = 0 at initialization). 
            // A fundamental relation about trafic gives : flow = concentration * speed.
            
            ask section{
                critical_concentration &lt;- 125.0 ; //Kc
                max_speed &lt;- 50 #km/#h; // Vl
                current_concentration &lt;- 0.0 ;
                current_flow &lt;- current_concentration * max_speed ;
                max_flow &lt;- critical_concentration * max_speed ; 
            }
                        
            // The concentration and flow ot first section are initialized.
            
            ask section[0]{
                current_concentration &lt;- nb_max_cars_on_section ;
                current_flow &lt;- current_concentration * max_speed ;
            }
            
            // The middle section is supposed to have a different maximum speed and a different critical concentration so that we can observe congestion phenomenon.
            // This middle section is green.
            
            ask section[int(nb_sections/2)] {
                    critical_concentration &lt;- 10.0 ; 
                    max_flow &lt;- critical_concentration * max_speed ; 
                    max_speed &lt;- 10 #km/#h; 
                    color &lt;- #green;
            }
        }
        
   // To update flow and concentration at each time step in each section, we use an offer and a demand function. 
   // These functions define the welcome capacity (offer) and the emission capacity (demand) of a section.
   
    reflex offer_function {
         ask section {
              if current_concentration &lt;= critical_concentration {
                offer &lt;- max_flow ;
              }
              else {
                offer &lt;- max([0 , (- max_flow / critical_concentration) * current_concentration + 2 * max_flow ]);
              }
          
      }
    }
    
    reflex demand_function {
        ask section{
              if current_concentration &lt;= critical_concentration {
                    demand &lt;- max([0 , ( max_flow / critical_concentration) * current_concentration]) ;
              }
              else {
                    demand &lt;- max_flow ;
              }
        }
    }
    
    // The flow and concentration are then updated according to the offer and demand functions of the current section, but also of the next and previous ones.
    
    // During a time step, the flow of a section take the minimum value between its demand and the offer of the next section.
    // The flow of the last section is equal to its demand. 
    
    reflex update_flow{
        ask section  {
            float next_offer &lt;-  (self.next != nil) ? (self.next).offer : self.demand;
            current_flow &lt;- min([self.demand, next_offer]);
        }
    }
    
    
    // After a time step, the concentration is updated from the current concentration, according to the incoming and outgoing concentrations.
    // The first section concentration on ly takes into account the outgoing concentration of vehicles.
    
    reflex update_concentration{
        ask section   {
            float previous_flow &lt;- (self.previous != nil) ? (self.previous).current_flow : 0.0;
            current_concentration &lt;- current_concentration + time_step/section_size *(previous_flow - self.current_flow) ;
        }   
    }
    
    // When there is less than one car left on the road, the simulation stops.
    
    reflex stop_simulation when: sum(section collect each.current_concentration) &lt; 1.0 {
        do pause;
    }
}

// A road is divided into sections. 
// Each section has a concentration, a flow, an offer and a demand, a critical concentration, a maximum speed and a maximum flow, 
// and a previous and a next section.

species section {
    float current_concentration  ;
    float current_flow  ;
    
    float offer ;
    float demand  ;
    
    rgb color;
    
    float critical_concentration ; 
    float max_speed ; 
    float max_flow ; 

    section previous ;
    section next ;
    
    // The width of a section depends on its concentration.
    
    aspect shape_section {
        draw shape + (1 + 15 * ln (current_concentration + 1)) color: color;        
    } 

}


experiment TraficGroup type: gui {

    // Users can chose the number of sections and the time step.

    parameter 'Number of sections' var: nb_sections category: "Section parameter";
    parameter 'Time step - DeltaT' var: time_step category: "Time parameter";
        
    output {
        
        // A monitor gives the number of cars on the road at every time step.
        
        monitor "Sum Concentrations" value: sum(section collect each.current_concentration);
        
        // A display shows the road. Section width depend on their concentration.
        
        display TheRoad{
            species section aspect: shape_section ;
        }
        
        // The greeen time series correspond to the middle section (on which concentration and maximum speed are lower).
        // The red time series correspond to the section just before the middle one.
                
        display Concentrations {
            chart "Concentrations" type: series  {
                data 'Section 0' value: section[0].current_concentration color: #gray marker: false ;               
                data 'Section 1' value: section[1].current_concentration color: #gray marker: false;
                data 'Section 2' value: section[2].current_concentration color: #gray marker: false;
                data 'Section 3' value: section[3].current_concentration color: #gray marker: false;                
                data 'Section 4' value: section[int(nb_sections/2 - 1 ) ].current_concentration color: #red marker: false;
                data 'Section 5' value: section[int(nb_sections/2)].current_concentration color: #green marker: false;
                data 'Section 6' value: section[6].current_concentration color: #gray marker: false;                
                data 'Section 7' value: section[7].current_concentration color: #gray marker: false;
                data 'Section 8' value: section[8].current_concentration color: #gray marker: false;
                data 'Section 9' value: section[9].current_concentration color: #gray marker: false;
                }
            }
            
            display Flows {
                chart "Flows" type: series  {
                data 'Section 0' value: section[0].current_flow color: #gray marker: false;             
                data 'Section 1' value: section[1].current_flow color: #gray marker: false;
                data 'Section 2' value: section[2].current_flow color: #gray marker: false;
                data 'Section 3' value: section[3].current_flow color: #gray marker: false;             
                data 'Section 4' value: section[int(nb_sections/2 - 1)].current_flow color: #red marker: false;
                data 'Section 5' value: section[int(nb_sections/2)].current_flow color: #green marker: false;
                data 'Section 6' value: section[6].current_flow color: #gray marker: false;             
                data 'Section 7' value: section[7].current_flow color: #gray marker: false;
                data 'Section 8' value: section[8].current_flow color: #gray marker: false;
                data 'Section 9' value: section[9].current_flow color: #gray marker: false;
                }
            }
    }
}
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/BC2019-Gama-Site/" class="nav-home"><img src="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png" alt="GAMA-Platform" width="66" height="58"/></a><div><h5>Docs</h5><a href="/BC2019-Gama-Site/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/BC2019-Gama-Site/docs/en/doc2.html">Guides (or other categories)</a><a href="/BC2019-Gama-Site/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/BC2019-Gama-Site/en/users.html">User Showcase</a><a href="http://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/BC2019-Gama-Site/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2019 GAMA-Platform</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0f9f28b9ab9efae89810921a351753b5',
                indexName: 'github',
                inputSelector: '#search_input_react'
              });
            </script></body></html>