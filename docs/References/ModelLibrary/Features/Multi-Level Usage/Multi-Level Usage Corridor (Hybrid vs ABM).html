<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>References/ModelLibrary/Features/Multi-Level Usage/Multi-Level Usage Corridor (Hybrid vs ABM) · Test Site</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="A website for testing"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="References/ModelLibrary/Features/Multi-Level Usage/Multi-Level Usage Corridor (Hybrid vs ABM) · Test Site"/><meta property="og:type" content="website"/><meta property="og:url" content="https://roiarthurb.github.io/BC2019-Gama-Site/"/><meta property="og:description" content="A website for testing"/><meta property="og:image" content="https://roiarthurb.github.io/BC2019-Gama-Site/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://roiarthurb.github.io/BC2019-Gama-Site/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/BC2019-Gama-Site/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/atom.xml" title="Test Site Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/feed.xml" title="Test Site Blog RSS Feed"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><link rel="stylesheet" href="/BC2019-Gama-Site/css/main.css"/><script src="/BC2019-Gama-Site/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/BC2019-Gama-Site/"><img class="logo" src="/BC2019-Gama-Site/img/favicon.ico" alt="Test Site"/><h2 class="headerTitleWithLogo">Test Site</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/BC2019-Gama-Site/docs/doc1" target="_self">Docs</a></li><li class=""><a href="/BC2019-Gama-Site/help" target="_self">Help</a></li><li class=""><a href="/BC2019-Gama-Site/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">References/ModelLibrary/Features/Multi-Level Usage/Multi-Level Usage Corridor (Hybrid vs ABM)</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="corridor-multi-level-architecture-with-mathematics-model-and-agent-based-model"></a><a href="#corridor-multi-level-architecture-with-mathematics-model-and-agent-based-model" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Corridor Multi-Level Architecture with Mathematics Model and Agent Based Model</h1>
<p>_Author : _</p>
<p>This model shows how to use multi-level architecture. Two corridors are presented : one which can capture the pedestrians going through it and computing for them the time before releasing them at the end of the corridor, and an other doing nothing, letting the pedestrians moving by themselves in the corridor.</p>
<p>Code of the model :</p>
<pre><code class="hljs">
model pedestrian_corridor_Hybrid_vs_ABM

<span class="hljs-keyword">global</span> 
{
    
    //Parameters <span class="hljs-keyword">of</span> the environment
    <span class="hljs-type">int</span> environment_width &lt;- <span class="hljs-number">200</span> const: <span class="hljs-keyword">true</span>;
    <span class="hljs-type">int</span> environment_height &lt;- <span class="hljs-number">200</span> const: <span class="hljs-keyword">true</span>;
    geometry shape &lt;- rectangle(environment_width, environment_height); 
    
    
    //Parameters <span class="hljs-keyword">of</span> the pedestrian agents
    rgb pedestrian_green &lt;- #green;
    
    <span class="hljs-type">float</span> pedestrian_size &lt;- <span class="hljs-number">1.0</span>;
    geometry pedestrian_shape &lt;- circle (pedestrian_size) ;
    <span class="hljs-type">float</span> pedestrian_speed &lt;- <span class="hljs-number">2.0</span>;
 
    //Parameters <span class="hljs-keyword">of</span> the corridors
    rgb corridor_color &lt;- rgb (<span class="hljs-string">'blue'</span>);
    <span class="hljs-type">int</span> corridor_width &lt;- <span class="hljs-number">160</span> depends_on: [environment_width];
    <span class="hljs-type">int</span> corridor_height &lt;- (<span class="hljs-type">int</span>(environment_height * <span class="hljs-number">0.05</span>));

    <span class="hljs-type">point</span> corridor_location_0 &lt;- {environment_width / <span class="hljs-number">2</span>, environment_height / <span class="hljs-number">4</span>};
    geometry corridor_shape_0 &lt;- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location_0) ;

    <span class="hljs-type">point</span> corridor_location_1 &lt;- {environment_width / <span class="hljs-number">2</span>, environment_height * <span class="hljs-number">0.75</span>};
    geometry corridor_shape_1 &lt;- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location_1) ;

    //Parameters <span class="hljs-keyword">of</span> pedestrian generation
    <span class="hljs-type">int</span> new_pedestian_generate_frequency &lt;- <span class="hljs-number">8</span>;
    <span class="hljs-type">point</span> pedestrian_source_0 &lt;- {<span class="hljs-number">0</span>, corridor_location_0.y} ;
    <span class="hljs-type">point</span> pedestrian_source_1 &lt;- {<span class="hljs-number">0</span>, corridor_location_1.y} ;
     
     
     
    init 
    {
        <span class="hljs-keyword">create</span> corridor number: <span class="hljs-number">2</span> <span class="hljs-keyword">returns</span>: new_corridors;
        
        ask (new_corridors at <span class="hljs-number">0</span>) 
        {
            <span class="hljs-keyword">do</span> init_corridor corridor_shape: corridor_shape_0 is_hybrid: <span class="hljs-keyword">false</span>;
        }

        ask (new_corridors at <span class="hljs-number">1</span>) 
        {
            <span class="hljs-keyword">do</span> init_corridor corridor_shape: corridor_shape_1 is_hybrid: <span class="hljs-keyword">true</span>; 
        }
    }

    //Generation <span class="hljs-keyword">of</span> pedestrians according <span class="hljs-keyword">to</span> the frequency <span class="hljs-keyword">of</span> generation : one <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> corridor
    reflex generate_pedestrians <span class="hljs-keyword">when</span>: ( (<span class="hljs-keyword">cycle</span> mod new_pedestian_generate_frequency) = <span class="hljs-number">0</span> ) 
    { 
        <span class="hljs-keyword">create</span> pedestrian number: <span class="hljs-number">2</span> <span class="hljs-keyword">returns</span>: new_pedestrians;
        
        ask (new_pedestrians at <span class="hljs-number">0</span>) 
        {
            <span class="hljs-keyword">do</span> init_location loc: pedestrian_source_0;
        }
        
        ask (new_pedestrians at <span class="hljs-number">1</span>) 
        {
            <span class="hljs-keyword">do</span> init_location loc: pedestrian_source_1;
        }
    }   
}


//Species <span class="hljs-keyword">for</span> the pedestrians which can <span class="hljs-keyword">move</span>
species pedestrian skills: [moving] {
    geometry shape &lt;- circle(pedestrian_size);
    rgb color;
    corridor last_corridor;
    <span class="hljs-type">point</span> target_location;
    <span class="hljs-type">float</span> speed &lt;- pedestrian_speed;
    
    //Initialisation <span class="hljs-keyword">of</span> the target <span class="hljs-keyword">location</span> according <span class="hljs-keyword">to</span> its generation <span class="hljs-keyword">location</span>
    action init_location (<span class="hljs-type">point</span> loc) {
        <span class="hljs-keyword">location</span> &lt;- loc;
        target_location &lt;- {environment_width, <span class="hljs-keyword">location</span>.y};
        heading &lt;- self towards (target_location);
    }

    //Reflex <span class="hljs-keyword">to</span> <span class="hljs-keyword">move</span> the agent <span class="hljs-keyword">to</span> its target <span class="hljs-keyword">location</span> <span class="hljs-keyword">and</span> make it die once it reached its target
    reflex move_left 
    {
        <span class="hljs-keyword">do</span> <span class="hljs-keyword">move</span> heading: (self) towards (target_location); 
        
        <span class="hljs-keyword">if</span> ( (target_location.x - <span class="hljs-keyword">location</span>.x) &lt;= speed ) 
        {
            <span class="hljs-keyword">do</span> die;
        }
    }
     
    aspect <span class="hljs-keyword">default</span> 
    {
        draw shape color: color;
    }
}

//Species <span class="hljs-keyword">for</span> the corridor which can capture pedestrians
species corridor  {
    <span class="hljs-type">bool</span> capture_pedestrians;
    
    
    action init_corridor (geometry corridor_shape, <span class="hljs-type">bool</span> is_hybrid) 
    {
        shape &lt;- corridor_shape;
        capture_pedestrians &lt;- is_hybrid;
    }

    <span class="hljs-type">float</span> max_speed &lt;- pedestrian_speed;
    <span class="hljs-type">float</span> macro_length min: <span class="hljs-number">0.0</span> &lt;- <span class="hljs-type">float</span>(corridor_width); // the length <span class="hljs-keyword">of</span> macro_patch
    
    //Species <span class="hljs-keyword">to</span> model the pedestrian captured <span class="hljs-keyword">by</span> the corridor
    species captured_pedestrian parent: pedestrian schedules: [] 
    {
        <span class="hljs-type">float</span> released_time;  
        
        aspect <span class="hljs-keyword">default</span> { }
    }
    
    init 
    { 
        <span class="hljs-keyword">create</span> corridor_info_drawer number: <span class="hljs-number">1</span> <span class="hljs-keyword">with</span>: [target :: self];
    }
    //Reflex <span class="hljs-keyword">to</span> capture the pedestrians overlapping the corridor ie entering the corridor 
    reflex <span class="hljs-keyword">aggregate</span> <span class="hljs-keyword">when</span>: capture_pedestrians 
    {
        list&lt;pedestrian&gt; tobe_captured_pedestrians &lt;- (pedestrian overlapping shape) <span class="hljs-keyword">where</span> ( (<span class="hljs-keyword">each</span>.last_corridor != self) <span class="hljs-keyword">and</span> ((<span class="hljs-keyword">each</span>.<span class="hljs-keyword">location</span>).x &lt; (self.<span class="hljs-keyword">location</span>).x) ) ; 
        
        <span class="hljs-keyword">if</span> !(empty (tobe_captured_pedestrians)) 
        {
            capture tobe_captured_pedestrians <span class="hljs-keyword">as</span>: captured_pedestrian <span class="hljs-keyword">returns</span>: cps { 
                last_corridor &lt;- myself;
            }
            <span class="hljs-keyword">if</span> !(empty (cps)) 
            {
                    //Computation <span class="hljs-keyword">of</span> the <span class="hljs-type">time</span> <span class="hljs-keyword">when</span> the pedestrians captured will be released according <span class="hljs-keyword">to</span> the speed
                    // <span class="hljs-keyword">and</span> the <span class="hljs-type">time</span> they should make <span class="hljs-keyword">to</span> pass the corridor <span class="hljs-keyword">if</span> they <span class="hljs-keyword">move</span> <span class="hljs-keyword">by</span> themselves
                    <span class="hljs-type">float</span> group_outgoing_time &lt;- <span class="hljs-type">time</span> + (corridor_width / (pedestrian_speed) ); 
                    <span class="hljs-keyword">loop</span> cp <span class="hljs-keyword">over</span>: cps 
                    {
                            cp.released_time &lt;- group_outgoing_time;
                    }
            }
        
        }
    }
    
    //Reflex <span class="hljs-keyword">to</span> <span class="hljs-keyword">release</span> the pedestrians <span class="hljs-keyword">when</span> we consider they were enough <span class="hljs-type">time</span> inside the corridor 
    reflex disaggregate  
    {
        list tobe_released_pedestrians &lt;- members <span class="hljs-keyword">where</span> (<span class="hljs-type">time</span> &gt;= (captured_pedestrian (<span class="hljs-keyword">each</span>)).released_time);
        
        <span class="hljs-keyword">if</span> !(empty (tobe_released_pedestrians)) 
        {
            
            <span class="hljs-keyword">release</span> tobe_released_pedestrians <span class="hljs-keyword">as</span>: pedestrian <span class="hljs-keyword">in</span>: world <span class="hljs-keyword">returns</span>: released_pedestrians;
            
            <span class="hljs-keyword">loop</span> rp <span class="hljs-keyword">over</span>: released_pedestrians 
            {
                rp.speed &lt;- pedestrian_speed;
                rp.<span class="hljs-keyword">location</span> &lt;- {((environment_width / <span class="hljs-number">2</span>) + (corridor_width / <span class="hljs-number">2</span>)), ((corridor_shape_1).<span class="hljs-keyword">location</span>).y};
            }
        }
    }
        
    aspect <span class="hljs-keyword">default</span> 
    {
        draw shape color: corridor_color;
    }
}
 
species corridor_info_drawer 
{
    corridor target;
    
    aspect base 
    {
        <span class="hljs-keyword">if</span> target.capture_pedestrians 
        {
            draw <span class="hljs-string">'Hybrid model (coupling: ABM and Mathematical Model)'</span> color: #blue size: <span class="hljs-number">7</span> at: {(target.<span class="hljs-keyword">location</span>).x - <span class="hljs-number">90</span>, (target.<span class="hljs-keyword">location</span>).y - <span class="hljs-number">10</span>};
            draw  <span class="hljs-string">'Aggregated agents: '</span> + string(length(target.members)) color: #black size: <span class="hljs-number">7</span> at: {(target.<span class="hljs-keyword">location</span>).x - <span class="hljs-number">30</span>, (target.<span class="hljs-keyword">location</span>).y + <span class="hljs-number">2</span>};
        } 
        <span class="hljs-keyword">else</span> 
        {
            draw <span class="hljs-string">'Agent-Based Model (ABM)'</span> color: #blue size: <span class="hljs-number">7</span> at: {(target.<span class="hljs-keyword">location</span>).x - <span class="hljs-number">40</span>, (target.<span class="hljs-keyword">location</span>).y - <span class="hljs-number">10</span>};
        }
    }
}

experiment default_experiment <span class="hljs-keyword">type</span>: gui 
{
    output 
    {
        display default_display 
        {
            species pedestrian;
            species corridor transparency: <span class="hljs-number">0.8</span>;
            species corridor_info_drawer aspect: base;
        }
    }
}
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/BC2019-Gama-Site/" class="nav-home"><img src="/BC2019-Gama-Site/img/favicon.ico" alt="Test Site" width="66" height="58"/></a><div><h5>Docs</h5><a href="/BC2019-Gama-Site/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/BC2019-Gama-Site/docs/en/doc2.html">Guides (or other categories)</a><a href="/BC2019-Gama-Site/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/BC2019-Gama-Site/en/users.html">User Showcase</a><a href="http://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/BC2019-Gama-Site/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://opensource.facebook.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/BC2019-Gama-Site/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2019 GAMA-Platform</section></footer></div></body></html>