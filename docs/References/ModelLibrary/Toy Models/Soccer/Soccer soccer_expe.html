<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>References/ModelLibrary/Toy Models/Soccer/Soccer soccer_expe · GAMA-Platform</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="GAMA, modeling made easy"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="References/ModelLibrary/Toy Models/Soccer/Soccer soccer_expe · GAMA-Platform"/><meta property="og:type" content="website"/><meta property="og:url" content="https://roiarthurb.github.io/BC2019-Gama-Site/"/><meta property="og:description" content="GAMA, modeling made easy"/><meta property="og:image" content="https://roiarthurb.github.io/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://roiarthurb.github.io/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><link rel="shortcut icon" href="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/atom.xml" title="GAMA-Platform Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/feed.xml" title="GAMA-Platform Blog RSS Feed"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/BC2019-Gama-Site/js/code-block-buttons.js"></script><link rel="stylesheet" href="/BC2019-Gama-Site/css/main.css"/><script src="/BC2019-Gama-Site/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/BC2019-Gama-Site/"><img class="logo" src="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png" alt="GAMA-Platform"/><h2 class="headerTitleWithLogo">GAMA-Platform</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a target="_self">Index</a></li><li class=""><a href="/BC2019-Gama-Site/docs/Home" target="_self">Docs</a></li><li class=""><a href="/BC2019-Gama-Site/help" target="_self">Help</a></li><li class=""><a href="/BC2019-Gama-Site/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">References/ModelLibrary/Toy Models/Soccer/Soccer soccer_expe</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="soccer-game-various-strategies"></a><a href="#soccer-game-various-strategies" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Soccer game (Various strategies)</h1>
<p><em>Author : Julien</em></p>
<p>This model shows a game between two teams, with the same of with different strategies :</p>
<ul>
<li>The &quot;stupidTeam&quot; has a very basic strategy : when a player has the ball, he runs to the ennemy goal, he runs to the ball otherwise.</li>
<li>The &quot;intelligentTeam&quot; is composed of players that each one have a strategical place wich they are able to keep. They also do pass when they are in dangerous position, to the &quot;safer&quot; player.
This model is designed to show how, with the same set of rules and some predefined actions, we can build a strategy of a team. You are free to change the imported files &quot;team1_strategy.gaml&quot; and &quot;team2_strategy.gaml&quot;, using the read-only and the read-write attributes of the mother species.</li>
</ul>
<p>Imported models :</p>
<pre><code class="hljs">
model soccerbase

species soccer_game {
    <span class="hljs-comment">// contains the global informations of the game</span>
    rgb back_color_team;
    rgb front_color_team;
    
    ball_sp ball; <span class="hljs-comment">// the ball agent</span>
    goal_sp front_goal; <span class="hljs-comment">// contains the goal at the front of the field (y = 120)</span>
    goal_sp back_goal; <span class="hljs-comment">// contains the goal at the back of the field (y = 0)</span>
    <span class="hljs-built_in">list</span>&lt;base_team&gt; <span class="hljs-built_in">teams</span>; <span class="hljs-comment">// contains the 2 teams</span>
    <span class="hljs-built_in">list</span>&lt;base_player&gt; players; <span class="hljs-comment">// contains all the players of the game</span>
    
    base_team team_possession; <span class="hljs-comment">// the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.</span>
    
    init {
        <span class="hljs-comment">// create the entities ball and the 2 goals</span>
        create ball_sp <span class="hljs-keyword">with</span>:[location::world.location] returns:var_ball;
        ball &lt;- first(var_ball);
        create goal_sp <span class="hljs-keyword">with</span>:[location::{world.location.x,<span class="hljs-number">120</span>},<span class="hljs-built_in">position</span>::<span class="hljs-string">"front"</span>] returns:var_goal1;
        front_goal &lt;- first(var_goal1);
        create goal_sp <span class="hljs-keyword">with</span>:[location::{world.location.x,<span class="hljs-number">0</span>},<span class="hljs-built_in">position</span>::<span class="hljs-string">"back"</span>] returns:var_goal2;
        back_goal &lt;- first(var_goal2);
    }
    
    <span class="hljs-built_in">action</span> reinit_phase {
        <span class="hljs-comment">// this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center</span>
        ask players {
            location &lt;- init_pos;
            previous_pos &lt;- init_pos;
        }
        ball.location &lt;- world.location;
        ball.destination &lt;- world.location;
        ball.<span class="hljs-built_in">speed</span> &lt;- <span class="hljs-number">0.0</span>;
    }
}

species base_player skills:[moving] {
    <span class="hljs-comment">// ATTRIBUTES ////////////////////////////////////////////////</span>
    
    <span class="hljs-comment">// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE</span>
    float recuperation_ability &lt;- <span class="hljs-number">0.2</span>; <span class="hljs-comment">// a mark from 0 to 1 to be able to catch the ball if another player has it</span>
    float speed_without_ball;
    float speed_with_ball;
    point previous_pos; <span class="hljs-comment">// used to apply inertia</span>
    bool displacement_effectued&lt;-<span class="hljs-literal">false</span> update:<span class="hljs-literal">false</span>; <span class="hljs-comment">// we can apply only one displacement by step !</span>
    
    <span class="hljs-comment">// ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)</span>
    base_team team;
    soccer_game game;
    base_team ennemy_team &lt;- <span class="hljs-literal">nil</span> update:first(game.<span class="hljs-built_in">teams</span> where (each.<span class="hljs-built_in">position</span> != team.<span class="hljs-built_in">position</span>));
    ball_sp ball &lt;- <span class="hljs-literal">nil</span> update:first(ball_sp);
    goal_sp own_goal &lt;- <span class="hljs-literal">nil</span> update:first(goal_sp where (each.<span class="hljs-built_in">position</span> = team.<span class="hljs-built_in">position</span>));
    goal_sp ennemy_goal &lt;- <span class="hljs-literal">nil</span> update:first(goal_sp where (each.<span class="hljs-built_in">position</span> != team.<span class="hljs-built_in">position</span>));
    <span class="hljs-comment">// ratio of avancement of the ball (from the point of view of the current team)</span>
    float ball_advancement &lt;- <span class="hljs-number">0.0</span> update:(team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) ? ball.location.y / <span class="hljs-number">120</span> : <span class="hljs-number">1</span> - ball.location.y / <span class="hljs-number">120</span>;
    
    bool possess_ball;
    point init_pos;
    point init_pos_in_percent;
    float distance_to_closest_ennemy_player &lt;- <span class="hljs-number">100.0</span> update:self distance_to closest_ennemy_player;
    <span class="hljs-comment">// the number of ennemy players in a range of 15 meters</span>
    int number_of_ennemy_player_in_range &lt;- <span class="hljs-number">0</span> update:length((game.players where (each.team != team)) where ((each intersects circle(<span class="hljs-number">15</span>))=<span class="hljs-literal">true</span>));
    float distance_to_ball &lt;- <span class="hljs-number">100.0</span> update:(ball = <span class="hljs-literal">nil</span>) ? <span class="hljs-number">100.0</span> : self distance_to ball;
    float distance_to_goal &lt;- <span class="hljs-number">100.0</span> update:(ennemy_goal = <span class="hljs-literal">nil</span>) ? <span class="hljs-number">100.0</span> : self distance_to ennemy_goal;
    <span class="hljs-comment">// the closest player of this team</span>
    base_player closest_friend_player &lt;- <span class="hljs-literal">nil</span> update:(ball = <span class="hljs-literal">nil</span>) ? base_player(<span class="hljs-literal">nil</span>) : first( (game.players where (each.team = team <span class="hljs-built_in">and</span> each != self)) 
        where (each distance_to self = <span class="hljs-built_in">min</span>( (game.players where (each.team = team <span class="hljs-built_in">and</span> each != self)) collect (each distance_to self) ) ) 
    );
    <span class="hljs-comment">// the closest ennemy player</span>
    base_player closest_ennemy_player &lt;- <span class="hljs-literal">nil</span> update:(ball = <span class="hljs-literal">nil</span>) ? base_player(<span class="hljs-literal">nil</span>) : first( (game.players where (each.team != team <span class="hljs-built_in">and</span> each != self)) 
        where (each distance_to self = <span class="hljs-built_in">min</span>( (game.players where (each.team != team <span class="hljs-built_in">and</span> each != self)) collect (each distance_to self) ) ) 
    );
    <span class="hljs-comment">// the player of this team wich has the best "position_mark"</span>
    base_player best_position_player &lt;- <span class="hljs-literal">nil</span> update:first((team.players where (each != self)) 
        where (each.position_mark = <span class="hljs-built_in">max</span>((team.players where (each != self)) collect (each.position_mark)))
    );
    float current_speed&lt;-<span class="hljs-number">1.0</span> update:(possess_ball) ? speed_with_ball : speed_without_ball;
    
    <span class="hljs-comment">// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE</span>
    float position_mark &lt;- <span class="hljs-number">0.0</span> update:-distance_to_goal; <span class="hljs-comment">// a mark attributed according to the position of the player (the higher the note is, the best the position is). </span>
    <span class="hljs-comment">// By default, this mark is equal to -distance_to_goal.</span>
    string status &lt;- <span class="hljs-string">""</span>; <span class="hljs-comment">// the current status of the player (can be useful to build the model)</span>
    geometry influence_area &lt;- <span class="hljs-literal">nil</span> update:circle(<span class="hljs-number">15</span>); <span class="hljs-comment">// the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.</span>

    
    <span class="hljs-comment">// CONSTRUCTOR /////////////////////////////////////////////</span>
    init {
        init_pos &lt;- location;
        previous_pos &lt;- location;
        possess_ball &lt;- <span class="hljs-literal">false</span>;
        speed_with_ball &lt;- <span class="hljs-number">0.4</span>;
        speed_without_ball &lt;- <span class="hljs-number">0.5</span>;
    }
    
    <span class="hljs-comment">// ACTIONS ////////////////////////////////////////////////////</span>
    
    <span class="hljs-comment">// ACTIONS TO CALL FROM THE STRATEGY FILE</span>
    <span class="hljs-comment">// action to run to a particular position</span>
    <span class="hljs-built_in">action</span> run_to(point target) {
        <span class="hljs-keyword">if</span> (!displacement_effectued) {
                <span class="hljs-keyword">do</span> <span class="hljs-built_in">goto</span> target:target <span class="hljs-built_in">speed</span>:current_speed;
            <span class="hljs-keyword">if</span> (possess_ball) {
                ball.location &lt;- location;
            }
            displacement_effectued &lt;- <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">else</span> {
            write <span class="hljs-string">"WARNING : only ONE action of displacement is allowed each step"</span>;
        }
    }
    
    <span class="hljs-comment">// action to run to the ball</span>
    <span class="hljs-built_in">action</span> run_to_ball {
        point targetPos;
        <span class="hljs-keyword">if</span> (ball.ball_direction intersects circle(<span class="hljs-number">1</span>)) {
            targetPos &lt;- ball.location;
        }
        <span class="hljs-keyword">else</span> {
            targetPos &lt;- (ball.ball_direction closest_points_with self) at <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">do</span> run_to(targetPos);
    }
    
    <span class="hljs-comment">// action to run to the ennemy goal</span>
    <span class="hljs-built_in">action</span> run_to_ennemy_goal {
        <span class="hljs-keyword">do</span> run_to( ennemy_goal.location );
    }
    
    <span class="hljs-comment">// action to run to its own goal</span>
    <span class="hljs-built_in">action</span> run_to_own_goal {
        <span class="hljs-keyword">do</span> run_to( own_goal.location );
    }
    
    <span class="hljs-comment">// action to mark a player</span>
    <span class="hljs-built_in">action</span> mark_player (base_player <span class="hljs-built_in">player</span>) {
        float rnd_area &lt;- <span class="hljs-number">4.0</span>; <span class="hljs-comment">// the player will choose a position in a square of rnd_area m.</span>
        point pos &lt;- (team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"front"</span>) ? {<span class="hljs-built_in">player</span>.location.x,<span class="hljs-built_in">player</span>.location.y-rnd_area/<span class="hljs-number">2</span>} : {<span class="hljs-built_in">player</span>.location.x,<span class="hljs-built_in">player</span>.location.y+rnd_area/<span class="hljs-number">2</span>};
        <span class="hljs-keyword">do</span> run_to( {pos.x-rnd_area/<span class="hljs-number">2</span>+rnd(rnd_area),pos.y-rnd_area/<span class="hljs-number">2</span>+rnd(rnd_area)} );
    }
    
    <span class="hljs-comment">// action ot shoot the ball to the ennemy goal</span>
    <span class="hljs-built_in">action</span> shoot {
        <span class="hljs-keyword">do</span> loose_ball;
        ask ball {
            <span class="hljs-keyword">do</span> shooted speed_atr:<span class="hljs-number">3.0</span> target_position:myself.ennemy_goal.location;
        }
    }
    
    <span class="hljs-comment">// action to pass the ball to an ally</span>
    <span class="hljs-built_in">action</span> pass_the_ball (base_player target_player) {
        <span class="hljs-keyword">do</span> loose_ball;
        ask ball {
            <span class="hljs-keyword">do</span> shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/<span class="hljs-number">15</span>;
        }
        team.called_player &lt;- target_player;
    }
    
    <span class="hljs-comment">// action to pass the ball to an ally</span>
    <span class="hljs-built_in">action</span> pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {
        <span class="hljs-keyword">do</span> loose_ball;
        ask ball {
            float offset &lt;- ((myself.team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) ? number_of_meter_ahead : -number_of_meter_ahead);
            point target_point &lt;- {target_player.location.x,target_player.location.y+offset};
            <span class="hljs-keyword">do</span> shooted target_position:target_point speed_atr:target_player.distance_to_ball/<span class="hljs-number">15</span>;
        }
        team.called_player &lt;- target_player;
    }
    
    <span class="hljs-comment">// ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE</span>
    <span class="hljs-comment">// try to take the ball if it is close enough</span>
    <span class="hljs-built_in">action</span> try_to_take_ball {
        <span class="hljs-comment">// if no player has the ball</span>
        <span class="hljs-keyword">if</span> (!team.possess_ball <span class="hljs-built_in">and</span> !ennemy_team.possess_ball) {
            <span class="hljs-comment">// if the player is the one called (result of a pass)</span>
            <span class="hljs-keyword">if</span> (team.called_player = self) {
                <span class="hljs-keyword">do</span> take_ball;
            }
            <span class="hljs-comment">// if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball</span>
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (flip(<span class="hljs-number">1</span>/(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>*ball.<span class="hljs-built_in">speed</span>))) {
                    <span class="hljs-keyword">do</span> take_ball;
                }
            }
        }
        <span class="hljs-comment">// the ball is possessed by the ennemy team</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ennemy_team.possess_ball) {
            <span class="hljs-comment">// try to catch the ball from the other player</span>
            <span class="hljs-keyword">if</span> flip(recuperation_ability) {
                <span class="hljs-keyword">do</span> take_ball;
            }
        }
    }
    
    <span class="hljs-comment">// action of taking the ball</span>
    <span class="hljs-built_in">action</span> take_ball {
        <span class="hljs-keyword">if</span> (ennemy_team.possess_ball) {
            ask ennemy_team.player_with_ball {
                <span class="hljs-keyword">do</span> loose_ball;
            }
        }
        possess_ball &lt;- <span class="hljs-literal">true</span>;
        ball.<span class="hljs-built_in">speed</span> &lt;- <span class="hljs-number">0.0</span>;
        ball.destination &lt;- ball.location;
        team.called_player &lt;- <span class="hljs-literal">nil</span>;
        team.player_with_ball &lt;- self;
        team.possess_ball &lt;- <span class="hljs-literal">true</span>;
        game.team_possession &lt;- team;
    }
    
    <span class="hljs-comment">// action of loosing the ball</span>
    <span class="hljs-built_in">action</span> loose_ball {
        possess_ball &lt;- <span class="hljs-literal">false</span>;
        team.player_with_ball &lt;- <span class="hljs-literal">nil</span>;
        team.possess_ball &lt;- <span class="hljs-literal">false</span>;
    }
    
    <span class="hljs-comment">// apply the inertia</span>
    <span class="hljs-built_in">action</span> apply_inertia {
        point prev_pos &lt;- location;
        point inertia_vect &lt;- {(location.x-previous_pos.x)*<span class="hljs-number">0.7</span>,(location.y-previous_pos.y)*<span class="hljs-number">0.7</span>};
        float max_inertia &lt;- current_speed;
        <span class="hljs-keyword">if</span> (norm(inertia_vect) &gt; max_inertia) {
            float inertia_x &lt;-  <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">abs</span>(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));
            float inertia_y &lt;-  <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">abs</span>(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));
            inertia_x &lt;- (inertia_vect.x &lt; <span class="hljs-number">0</span>) ? -inertia_x : inertia_x;
            inertia_y &lt;- (inertia_vect.y &lt; <span class="hljs-number">0</span>) ? -inertia_y : inertia_y;
            inertia_vect &lt;- {inertia_x,inertia_y};
        }
        location &lt;- location + inertia_vect;
        previous_pos &lt;- prev_pos;
    }
    
    <span class="hljs-comment">// useful functions</span>
    <span class="hljs-comment">// this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point.</span>
    float getXPos(float x_ratio) {
        float result;
        <span class="hljs-keyword">if</span> (team.<span class="hljs-built_in">position</span>=<span class="hljs-string">"back"</span>) {
            result &lt;- <span class="hljs-number">90</span>-x_ratio*<span class="hljs-number">90</span>;
        }
        <span class="hljs-keyword">else</span> {
            result &lt;- x_ratio*<span class="hljs-number">90</span>;
        }
        return result;
    }
    
    <span class="hljs-comment">// this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point.</span>
    float getYPos(float y_ratio) {
        float result;
        <span class="hljs-keyword">if</span> (team.<span class="hljs-built_in">position</span>=<span class="hljs-string">"back"</span>) {
            result &lt;- y_ratio*<span class="hljs-number">120</span>;
        }
        <span class="hljs-keyword">else</span> {
            result &lt;- <span class="hljs-number">120</span>-y_ratio*<span class="hljs-number">120</span>;
        }
        return result;
    }
    
    <span class="hljs-comment">///////////////////////////////////////////////////////</span>
    
    <span class="hljs-comment">// The update function, calls the adequate behavior</span>
    reflex update when:cycle&gt;<span class="hljs-number">1</span> {
        <span class="hljs-keyword">do</span> apply_inertia;
        <span class="hljs-comment">// verify if it is a non-offside position</span>
        <span class="hljs-keyword">if</span> ( (((team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) <span class="hljs-built_in">and</span> (location.y &gt; team.offside_pos))
            <span class="hljs-built_in">or</span> ((team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"front"</span>) <span class="hljs-built_in">and</span> (location.y &lt; team.offside_pos))) 
            <span class="hljs-built_in">and</span> (!possess_ball) <span class="hljs-built_in">and</span> (self != team.called_player)
        ) {
            <span class="hljs-comment">// offside position, go back to a correct position</span>
            point target_pos &lt;- {location.x,(team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) ? location.y-current_speed:location.y+current_speed};
            <span class="hljs-keyword">do</span> run_to(target_pos);
            status &lt;- <span class="hljs-string">"offside position !"</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((distance_to_ball &lt; <span class="hljs-number">2</span>) <span class="hljs-built_in">and</span> !possess_ball) {
            <span class="hljs-keyword">do</span> try_to_take_ball;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (game.team_possession = team) {
            <span class="hljs-keyword">do</span> offensive_behavior;
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">do</span> defensive_behavior;
        }
    }
    
    <span class="hljs-comment">// defensive behavior, need to be redefined in the strategy file.</span>
    <span class="hljs-comment">// this action is called when the last player who was holding the ball was a player of the ennemy team</span>
    <span class="hljs-built_in">action</span> defensive_behavior virtual:<span class="hljs-literal">true</span> {
        
    }
    <span class="hljs-comment">// defensive behavior, need to be redefined in the strategy file.</span>
    <span class="hljs-comment">// this action is called when the last player who was holding the ball was a player of this team</span>
    <span class="hljs-built_in">action</span> offensive_behavior virtual:<span class="hljs-literal">true</span> {
        
    }
    
    
    <span class="hljs-comment">// ASPECT ////////////////////////////////////////////////////////</span>
    aspect <span class="hljs-built_in">player</span> {
        <span class="hljs-comment">// the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.</span>
        <span class="hljs-keyword">if</span> (possess_ball) {
            draw square(<span class="hljs-number">2</span>) color:(team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) ? game.back_color_team : game.front_color_team;
        }
        <span class="hljs-keyword">else</span> {
            draw circle(<span class="hljs-number">1</span>) color:(team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) ? game.back_color_team : game.front_color_team;
        }
    }
}



species base_team {
    <span class="hljs-comment">// ATTRIBUTES ////////////////////////////////////////////////</span>
    
    <span class="hljs-comment">// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE</span>
    float offside_pos &lt;- <span class="hljs-number">0.0</span> update: (<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) ? <span class="hljs-built_in">max</span>((game.players where (each.team != self)) collect (each.location.y))
        : <span class="hljs-built_in">min</span>((game.players where (each.team != self)) collect (each.location.y));
    
    <span class="hljs-comment">// ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)</span>
    string <span class="hljs-built_in">position</span>; <span class="hljs-comment">// can be "front" or "back".</span>
    <span class="hljs-built_in">list</span>&lt;base_player&gt; players; <span class="hljs-comment">// all the players of the team.</span>
    soccer_game game;
    
    base_player closest_player_to_ball &lt;- first(players) update: first( players where (each distance_to each.ball = <span class="hljs-built_in">min</span> (players collect (each distance_to each.ball) ) ) );
    base_player called_player;
    bool possess_ball &lt;- <span class="hljs-literal">false</span>;<span class="hljs-comment">// update: ! empty ( players where (each.possess_ball=true) );</span>
    base_player player_with_ball &lt;- <span class="hljs-literal">nil</span>;<span class="hljs-comment">// update: first(players where (each.possess_ball = true));</span>
    
    <span class="hljs-comment">// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE</span>
    <span class="hljs-built_in">list</span>&lt;point&gt; player_init_position;
}

species ball_sp skills:[moving] {
    <span class="hljs-comment">// The ball agent.</span>
    float <span class="hljs-built_in">speed</span> &lt;- <span class="hljs-number">0.0</span>;
    geometry ball_direction; <span class="hljs-comment">// the direction of the ball is used to be followed by the player</span>
    reflex update {
        <span class="hljs-built_in">speed</span> &lt;- <span class="hljs-built_in">speed</span>*<span class="hljs-number">0.95</span>;
        float future_speed &lt;- <span class="hljs-built_in">speed</span>;
        point tmpPos&lt;-location;
        loop i <span class="hljs-keyword">from</span>:<span class="hljs-number">0</span> <span class="hljs-keyword">to</span>:<span class="hljs-number">10</span> {
            tmpPos &lt;- {tmpPos.x+<span class="hljs-built_in">cos</span>(heading)*<span class="hljs-built_in">speed</span>,tmpPos.y+<span class="hljs-built_in">sin</span>(heading)*<span class="hljs-built_in">speed</span>};
            future_speed &lt;- future_speed*<span class="hljs-number">0.9</span>;
        }
        ball_direction &lt;- line([location,tmpPos]);
        <span class="hljs-keyword">do</span> wander amplitude:<span class="hljs-number">1</span>;
        
        <span class="hljs-comment">// anticipation of the ball position to detect a goal</span>
        <span class="hljs-keyword">if</span> ((location.y+<span class="hljs-built_in">sin</span>(heading)*<span class="hljs-built_in">speed</span>) &gt; <span class="hljs-number">120</span>) {
            write <span class="hljs-string">"back team score a goal !!"</span>;
            ask first(soccer_game) {
                <span class="hljs-keyword">do</span> reinit_phase;
            }
        }
        <span class="hljs-keyword">if</span> ((location.y+<span class="hljs-built_in">sin</span>(heading)*<span class="hljs-built_in">speed</span>) &lt; <span class="hljs-number">0</span>) {
            write <span class="hljs-string">"front team score a goal !!"</span>;
            ask first(soccer_game) {
                <span class="hljs-keyword">do</span> reinit_phase;
            }
        }
    }
    <span class="hljs-built_in">action</span> shooted (point target_position, float speed_atr) {
        <span class="hljs-comment">// action called when a player shoots the ball</span>
        <span class="hljs-built_in">speed</span> &lt;- speed_atr;
        <span class="hljs-keyword">do</span> <span class="hljs-built_in">goto</span> target:target_position;
    }
    
    aspect ball {
        draw circle(<span class="hljs-number">0.5</span>) color:<span class="hljs-meta">#white;</span>
    }
}

species goal_sp {
    string <span class="hljs-built_in">position</span>; <span class="hljs-comment">// can be "front" or "back".</span>
    
    init {
        create goal_keeper <span class="hljs-keyword">with</span>:[<span class="hljs-built_in">position</span>::<span class="hljs-built_in">position</span>];
    }
    
    aspect goal {
        draw rectangle(<span class="hljs-number">7.32</span>,<span class="hljs-number">1.0</span>) color:<span class="hljs-meta">#black;</span>
    }
}

species goal_keeper {
    <span class="hljs-comment">// the goal has a basic behavior : he tries to catch the ball when it is close enough, and when </span>
    string <span class="hljs-built_in">position</span>; <span class="hljs-comment">// can be "front" or "back".</span>
    ball_sp ball &lt;- <span class="hljs-literal">nil</span> update:first(ball_sp);
    
    reflex update when:cycle&gt;<span class="hljs-number">0</span> {
        location &lt;- {ball.location.x/<span class="hljs-number">90</span>*<span class="hljs-number">12</span>+(<span class="hljs-number">90</span>-<span class="hljs-number">12</span>)/<span class="hljs-number">2</span>,location.y};
        <span class="hljs-keyword">if</span> (ball distance_to self &lt; <span class="hljs-number">2</span>) {
            <span class="hljs-keyword">if</span> (flip(<span class="hljs-number">1</span>/(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>*ball.<span class="hljs-built_in">speed</span>))) {
                first(soccer_game).team_possession &lt;- first(first(soccer_game).<span class="hljs-built_in">teams</span> where (each.<span class="hljs-built_in">position</span> = <span class="hljs-built_in">position</span>));
                ask ball {
                    <span class="hljs-keyword">do</span> shooted ({<span class="hljs-number">30</span>+rnd(<span class="hljs-number">30</span>),<span class="hljs-number">60</span>},<span class="hljs-number">5.0</span>);
                }
            }
        }
    }
    
    init {
        location &lt;- {<span class="hljs-number">45</span>,(<span class="hljs-built_in">position</span>=<span class="hljs-string">"front"</span>) ? <span class="hljs-number">117</span> : <span class="hljs-number">3</span>};
    }
    
    <span class="hljs-built_in">action</span> offensive_behavior {
    }
    
    <span class="hljs-built_in">action</span> defensive_behavior {
    }
    
    aspect goal_keeper {
        draw circle(<span class="hljs-number">1</span>) color:(<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) ? first(soccer_game).back_color_team : first(soccer_game).front_color_team;
    }
}
</code></pre>
<pre><code class="hljs">
model team2strategy

<span class="hljs-keyword">import</span> <span class="hljs-string">"./soccer_base.gaml"</span>

species player_stupidTeam parent:base_player {
    <span class="hljs-comment">// READ ONLY ATTRIBUTES :</span>
    <span class="hljs-comment">// position : can be "front" or "back".</span>
    <span class="hljs-comment">// players : list of all the players of the team.</span>
    <span class="hljs-comment">// game</span>
    <span class="hljs-comment">//closest_player_to_ball</span>
    <span class="hljs-comment">// called_player : the player called for a pass</span>
    <span class="hljs-comment">// possess_ball : true or false</span>
    <span class="hljs-comment">// player_with_ball : player currently with the ball</span>
    
    <span class="hljs-comment">// READ AND WRITE ATTRIBUTES :</span>
    <span class="hljs-comment">// position_mark</span>
    <span class="hljs-comment">// status : the current status of the player (can be useful to build the model)</span>
    <span class="hljs-comment">// influence_area : the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location. </span>
    
    action defensive_behavior { 
        <span class="hljs-comment">// very basic defensive behavior : run to the ball</span>
        <span class="hljs-keyword">do</span> run_to_ball;
    }
    
    action offensive_behavior { 
        <span class="hljs-comment">// very basic offensive behavior : run to the ennemy goal, or shoot the ball when close enough from the ennemy goal.</span>
        <span class="hljs-keyword">if</span> ((possess_ball) <span class="hljs-keyword">and</span> (distance_to_goal &lt; <span class="hljs-number">30</span>)) {
            <span class="hljs-keyword">do</span> shoot;
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">do</span> run_to_ennemy_goal;
        }
    }
    
}

species stupidTeam parent:base_team {
    <span class="hljs-comment">// READ ONLY ATTRIBUTES :</span>
    <span class="hljs-comment">// position : can be "front" or "back".</span>
    <span class="hljs-comment">// players : list of all the players of the team.</span>
    <span class="hljs-comment">// game.</span>
    <span class="hljs-comment">// closest_player_to_ball.</span>
    <span class="hljs-comment">// called_player : the player called for a pass.</span>
    <span class="hljs-comment">// possess_ball : true when a player of the team possess the ball.</span>
    <span class="hljs-comment">// player_with_ball</span>
    
    <span class="hljs-comment">// READ AND WRITE ATTRIBUTES :</span>
    <span class="hljs-comment">// player_init_position</span>
    
    <span class="hljs-comment">// initial position of the player in percentage : for each point,</span>
    <span class="hljs-comment">//    the first value corresponds to the percentage from left to right (0 for the point the most in the left side)</span>
    <span class="hljs-comment">//    the second value corresponds to the percentage from the goal position to the mid position (0 for the goal position)</span>
    list&lt;point&gt; player_init_position &lt;- [{<span class="hljs-number">20</span>,<span class="hljs-number">20</span>},{<span class="hljs-number">50</span>,<span class="hljs-number">20</span>},{<span class="hljs-number">80</span>,<span class="hljs-number">20</span>},{<span class="hljs-number">30</span>,<span class="hljs-number">50</span>},{<span class="hljs-number">70</span>,<span class="hljs-number">50</span>},{<span class="hljs-number">50</span>,<span class="hljs-number">70</span>},{<span class="hljs-number">30</span>,<span class="hljs-number">90</span>},{<span class="hljs-number">50</span>,<span class="hljs-number">90</span>},{<span class="hljs-number">70</span>,<span class="hljs-number">90</span>}];
}

</code></pre>
<pre><code class="hljs">
model soccerbase

species soccer_game {
    <span class="hljs-comment">// contains the global informations of the game</span>
    rgb back_color_team;
    rgb front_color_team;
    
    ball_sp ball; <span class="hljs-comment">// the ball agent</span>
    goal_sp front_goal; <span class="hljs-comment">// contains the goal at the front of the field (y = 120)</span>
    goal_sp back_goal; <span class="hljs-comment">// contains the goal at the back of the field (y = 0)</span>
    <span class="hljs-built_in">list</span>&lt;base_team&gt; <span class="hljs-built_in">teams</span>; <span class="hljs-comment">// contains the 2 teams</span>
    <span class="hljs-built_in">list</span>&lt;base_player&gt; players; <span class="hljs-comment">// contains all the players of the game</span>
    
    base_team team_possession; <span class="hljs-comment">// the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.</span>
    
    init {
        <span class="hljs-comment">// create the entities ball and the 2 goals</span>
        create ball_sp <span class="hljs-keyword">with</span>:[location::world.location] returns:var_ball;
        ball &lt;- first(var_ball);
        create goal_sp <span class="hljs-keyword">with</span>:[location::{world.location.x,<span class="hljs-number">120</span>},<span class="hljs-built_in">position</span>::<span class="hljs-string">"front"</span>] returns:var_goal1;
        front_goal &lt;- first(var_goal1);
        create goal_sp <span class="hljs-keyword">with</span>:[location::{world.location.x,<span class="hljs-number">0</span>},<span class="hljs-built_in">position</span>::<span class="hljs-string">"back"</span>] returns:var_goal2;
        back_goal &lt;- first(var_goal2);
    }
    
    <span class="hljs-built_in">action</span> reinit_phase {
        <span class="hljs-comment">// this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center</span>
        ask players {
            location &lt;- init_pos;
            previous_pos &lt;- init_pos;
        }
        ball.location &lt;- world.location;
        ball.destination &lt;- world.location;
        ball.<span class="hljs-built_in">speed</span> &lt;- <span class="hljs-number">0.0</span>;
    }
}

species base_player skills:[moving] {
    <span class="hljs-comment">// ATTRIBUTES ////////////////////////////////////////////////</span>
    
    <span class="hljs-comment">// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE</span>
    float recuperation_ability &lt;- <span class="hljs-number">0.2</span>; <span class="hljs-comment">// a mark from 0 to 1 to be able to catch the ball if another player has it</span>
    float speed_without_ball;
    float speed_with_ball;
    point previous_pos; <span class="hljs-comment">// used to apply inertia</span>
    bool displacement_effectued&lt;-<span class="hljs-literal">false</span> update:<span class="hljs-literal">false</span>; <span class="hljs-comment">// we can apply only one displacement by step !</span>
    
    <span class="hljs-comment">// ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)</span>
    base_team team;
    soccer_game game;
    base_team ennemy_team &lt;- <span class="hljs-literal">nil</span> update:first(game.<span class="hljs-built_in">teams</span> where (each.<span class="hljs-built_in">position</span> != team.<span class="hljs-built_in">position</span>));
    ball_sp ball &lt;- <span class="hljs-literal">nil</span> update:first(ball_sp);
    goal_sp own_goal &lt;- <span class="hljs-literal">nil</span> update:first(goal_sp where (each.<span class="hljs-built_in">position</span> = team.<span class="hljs-built_in">position</span>));
    goal_sp ennemy_goal &lt;- <span class="hljs-literal">nil</span> update:first(goal_sp where (each.<span class="hljs-built_in">position</span> != team.<span class="hljs-built_in">position</span>));
    <span class="hljs-comment">// ratio of avancement of the ball (from the point of view of the current team)</span>
    float ball_advancement &lt;- <span class="hljs-number">0.0</span> update:(team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) ? ball.location.y / <span class="hljs-number">120</span> : <span class="hljs-number">1</span> - ball.location.y / <span class="hljs-number">120</span>;
    
    bool possess_ball;
    point init_pos;
    point init_pos_in_percent;
    float distance_to_closest_ennemy_player &lt;- <span class="hljs-number">100.0</span> update:self distance_to closest_ennemy_player;
    <span class="hljs-comment">// the number of ennemy players in a range of 15 meters</span>
    int number_of_ennemy_player_in_range &lt;- <span class="hljs-number">0</span> update:length((game.players where (each.team != team)) where ((each intersects circle(<span class="hljs-number">15</span>))=<span class="hljs-literal">true</span>));
    float distance_to_ball &lt;- <span class="hljs-number">100.0</span> update:(ball = <span class="hljs-literal">nil</span>) ? <span class="hljs-number">100.0</span> : self distance_to ball;
    float distance_to_goal &lt;- <span class="hljs-number">100.0</span> update:(ennemy_goal = <span class="hljs-literal">nil</span>) ? <span class="hljs-number">100.0</span> : self distance_to ennemy_goal;
    <span class="hljs-comment">// the closest player of this team</span>
    base_player closest_friend_player &lt;- <span class="hljs-literal">nil</span> update:(ball = <span class="hljs-literal">nil</span>) ? base_player(<span class="hljs-literal">nil</span>) : first( (game.players where (each.team = team <span class="hljs-built_in">and</span> each != self)) 
        where (each distance_to self = <span class="hljs-built_in">min</span>( (game.players where (each.team = team <span class="hljs-built_in">and</span> each != self)) collect (each distance_to self) ) ) 
    );
    <span class="hljs-comment">// the closest ennemy player</span>
    base_player closest_ennemy_player &lt;- <span class="hljs-literal">nil</span> update:(ball = <span class="hljs-literal">nil</span>) ? base_player(<span class="hljs-literal">nil</span>) : first( (game.players where (each.team != team <span class="hljs-built_in">and</span> each != self)) 
        where (each distance_to self = <span class="hljs-built_in">min</span>( (game.players where (each.team != team <span class="hljs-built_in">and</span> each != self)) collect (each distance_to self) ) ) 
    );
    <span class="hljs-comment">// the player of this team wich has the best "position_mark"</span>
    base_player best_position_player &lt;- <span class="hljs-literal">nil</span> update:first((team.players where (each != self)) 
        where (each.position_mark = <span class="hljs-built_in">max</span>((team.players where (each != self)) collect (each.position_mark)))
    );
    float current_speed&lt;-<span class="hljs-number">1.0</span> update:(possess_ball) ? speed_with_ball : speed_without_ball;
    
    <span class="hljs-comment">// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE</span>
    float position_mark &lt;- <span class="hljs-number">0.0</span> update:-distance_to_goal; <span class="hljs-comment">// a mark attributed according to the position of the player (the higher the note is, the best the position is). </span>
    <span class="hljs-comment">// By default, this mark is equal to -distance_to_goal.</span>
    string status &lt;- <span class="hljs-string">""</span>; <span class="hljs-comment">// the current status of the player (can be useful to build the model)</span>
    geometry influence_area &lt;- <span class="hljs-literal">nil</span> update:circle(<span class="hljs-number">15</span>); <span class="hljs-comment">// the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.</span>

    
    <span class="hljs-comment">// CONSTRUCTOR /////////////////////////////////////////////</span>
    init {
        init_pos &lt;- location;
        previous_pos &lt;- location;
        possess_ball &lt;- <span class="hljs-literal">false</span>;
        speed_with_ball &lt;- <span class="hljs-number">0.4</span>;
        speed_without_ball &lt;- <span class="hljs-number">0.5</span>;
    }
    
    <span class="hljs-comment">// ACTIONS ////////////////////////////////////////////////////</span>
    
    <span class="hljs-comment">// ACTIONS TO CALL FROM THE STRATEGY FILE</span>
    <span class="hljs-comment">// action to run to a particular position</span>
    <span class="hljs-built_in">action</span> run_to(point target) {
        <span class="hljs-keyword">if</span> (!displacement_effectued) {
                <span class="hljs-keyword">do</span> <span class="hljs-built_in">goto</span> target:target <span class="hljs-built_in">speed</span>:current_speed;
            <span class="hljs-keyword">if</span> (possess_ball) {
                ball.location &lt;- location;
            }
            displacement_effectued &lt;- <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">else</span> {
            write <span class="hljs-string">"WARNING : only ONE action of displacement is allowed each step"</span>;
        }
    }
    
    <span class="hljs-comment">// action to run to the ball</span>
    <span class="hljs-built_in">action</span> run_to_ball {
        point targetPos;
        <span class="hljs-keyword">if</span> (ball.ball_direction intersects circle(<span class="hljs-number">1</span>)) {
            targetPos &lt;- ball.location;
        }
        <span class="hljs-keyword">else</span> {
            targetPos &lt;- (ball.ball_direction closest_points_with self) at <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">do</span> run_to(targetPos);
    }
    
    <span class="hljs-comment">// action to run to the ennemy goal</span>
    <span class="hljs-built_in">action</span> run_to_ennemy_goal {
        <span class="hljs-keyword">do</span> run_to( ennemy_goal.location );
    }
    
    <span class="hljs-comment">// action to run to its own goal</span>
    <span class="hljs-built_in">action</span> run_to_own_goal {
        <span class="hljs-keyword">do</span> run_to( own_goal.location );
    }
    
    <span class="hljs-comment">// action to mark a player</span>
    <span class="hljs-built_in">action</span> mark_player (base_player <span class="hljs-built_in">player</span>) {
        float rnd_area &lt;- <span class="hljs-number">4.0</span>; <span class="hljs-comment">// the player will choose a position in a square of rnd_area m.</span>
        point pos &lt;- (team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"front"</span>) ? {<span class="hljs-built_in">player</span>.location.x,<span class="hljs-built_in">player</span>.location.y-rnd_area/<span class="hljs-number">2</span>} : {<span class="hljs-built_in">player</span>.location.x,<span class="hljs-built_in">player</span>.location.y+rnd_area/<span class="hljs-number">2</span>};
        <span class="hljs-keyword">do</span> run_to( {pos.x-rnd_area/<span class="hljs-number">2</span>+rnd(rnd_area),pos.y-rnd_area/<span class="hljs-number">2</span>+rnd(rnd_area)} );
    }
    
    <span class="hljs-comment">// action ot shoot the ball to the ennemy goal</span>
    <span class="hljs-built_in">action</span> shoot {
        <span class="hljs-keyword">do</span> loose_ball;
        ask ball {
            <span class="hljs-keyword">do</span> shooted speed_atr:<span class="hljs-number">3.0</span> target_position:myself.ennemy_goal.location;
        }
    }
    
    <span class="hljs-comment">// action to pass the ball to an ally</span>
    <span class="hljs-built_in">action</span> pass_the_ball (base_player target_player) {
        <span class="hljs-keyword">do</span> loose_ball;
        ask ball {
            <span class="hljs-keyword">do</span> shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/<span class="hljs-number">15</span>;
        }
        team.called_player &lt;- target_player;
    }
    
    <span class="hljs-comment">// action to pass the ball to an ally</span>
    <span class="hljs-built_in">action</span> pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {
        <span class="hljs-keyword">do</span> loose_ball;
        ask ball {
            float offset &lt;- ((myself.team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) ? number_of_meter_ahead : -number_of_meter_ahead);
            point target_point &lt;- {target_player.location.x,target_player.location.y+offset};
            <span class="hljs-keyword">do</span> shooted target_position:target_point speed_atr:target_player.distance_to_ball/<span class="hljs-number">15</span>;
        }
        team.called_player &lt;- target_player;
    }
    
    <span class="hljs-comment">// ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE</span>
    <span class="hljs-comment">// try to take the ball if it is close enough</span>
    <span class="hljs-built_in">action</span> try_to_take_ball {
        <span class="hljs-comment">// if no player has the ball</span>
        <span class="hljs-keyword">if</span> (!team.possess_ball <span class="hljs-built_in">and</span> !ennemy_team.possess_ball) {
            <span class="hljs-comment">// if the player is the one called (result of a pass)</span>
            <span class="hljs-keyword">if</span> (team.called_player = self) {
                <span class="hljs-keyword">do</span> take_ball;
            }
            <span class="hljs-comment">// if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball</span>
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (flip(<span class="hljs-number">1</span>/(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>*ball.<span class="hljs-built_in">speed</span>))) {
                    <span class="hljs-keyword">do</span> take_ball;
                }
            }
        }
        <span class="hljs-comment">// the ball is possessed by the ennemy team</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ennemy_team.possess_ball) {
            <span class="hljs-comment">// try to catch the ball from the other player</span>
            <span class="hljs-keyword">if</span> flip(recuperation_ability) {
                <span class="hljs-keyword">do</span> take_ball;
            }
        }
    }
    
    <span class="hljs-comment">// action of taking the ball</span>
    <span class="hljs-built_in">action</span> take_ball {
        <span class="hljs-keyword">if</span> (ennemy_team.possess_ball) {
            ask ennemy_team.player_with_ball {
                <span class="hljs-keyword">do</span> loose_ball;
            }
        }
        possess_ball &lt;- <span class="hljs-literal">true</span>;
        ball.<span class="hljs-built_in">speed</span> &lt;- <span class="hljs-number">0.0</span>;
        ball.destination &lt;- ball.location;
        team.called_player &lt;- <span class="hljs-literal">nil</span>;
        team.player_with_ball &lt;- self;
        team.possess_ball &lt;- <span class="hljs-literal">true</span>;
        game.team_possession &lt;- team;
    }
    
    <span class="hljs-comment">// action of loosing the ball</span>
    <span class="hljs-built_in">action</span> loose_ball {
        possess_ball &lt;- <span class="hljs-literal">false</span>;
        team.player_with_ball &lt;- <span class="hljs-literal">nil</span>;
        team.possess_ball &lt;- <span class="hljs-literal">false</span>;
    }
    
    <span class="hljs-comment">// apply the inertia</span>
    <span class="hljs-built_in">action</span> apply_inertia {
        point prev_pos &lt;- location;
        point inertia_vect &lt;- {(location.x-previous_pos.x)*<span class="hljs-number">0.7</span>,(location.y-previous_pos.y)*<span class="hljs-number">0.7</span>};
        float max_inertia &lt;- current_speed;
        <span class="hljs-keyword">if</span> (norm(inertia_vect) &gt; max_inertia) {
            float inertia_x &lt;-  <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">abs</span>(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));
            float inertia_y &lt;-  <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">abs</span>(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));
            inertia_x &lt;- (inertia_vect.x &lt; <span class="hljs-number">0</span>) ? -inertia_x : inertia_x;
            inertia_y &lt;- (inertia_vect.y &lt; <span class="hljs-number">0</span>) ? -inertia_y : inertia_y;
            inertia_vect &lt;- {inertia_x,inertia_y};
        }
        location &lt;- location + inertia_vect;
        previous_pos &lt;- prev_pos;
    }
    
    <span class="hljs-comment">// useful functions</span>
    <span class="hljs-comment">// this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point.</span>
    float getXPos(float x_ratio) {
        float result;
        <span class="hljs-keyword">if</span> (team.<span class="hljs-built_in">position</span>=<span class="hljs-string">"back"</span>) {
            result &lt;- <span class="hljs-number">90</span>-x_ratio*<span class="hljs-number">90</span>;
        }
        <span class="hljs-keyword">else</span> {
            result &lt;- x_ratio*<span class="hljs-number">90</span>;
        }
        return result;
    }
    
    <span class="hljs-comment">// this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point.</span>
    float getYPos(float y_ratio) {
        float result;
        <span class="hljs-keyword">if</span> (team.<span class="hljs-built_in">position</span>=<span class="hljs-string">"back"</span>) {
            result &lt;- y_ratio*<span class="hljs-number">120</span>;
        }
        <span class="hljs-keyword">else</span> {
            result &lt;- <span class="hljs-number">120</span>-y_ratio*<span class="hljs-number">120</span>;
        }
        return result;
    }
    
    <span class="hljs-comment">///////////////////////////////////////////////////////</span>
    
    <span class="hljs-comment">// The update function, calls the adequate behavior</span>
    reflex update when:cycle&gt;<span class="hljs-number">1</span> {
        <span class="hljs-keyword">do</span> apply_inertia;
        <span class="hljs-comment">// verify if it is a non-offside position</span>
        <span class="hljs-keyword">if</span> ( (((team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) <span class="hljs-built_in">and</span> (location.y &gt; team.offside_pos))
            <span class="hljs-built_in">or</span> ((team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"front"</span>) <span class="hljs-built_in">and</span> (location.y &lt; team.offside_pos))) 
            <span class="hljs-built_in">and</span> (!possess_ball) <span class="hljs-built_in">and</span> (self != team.called_player)
        ) {
            <span class="hljs-comment">// offside position, go back to a correct position</span>
            point target_pos &lt;- {location.x,(team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) ? location.y-current_speed:location.y+current_speed};
            <span class="hljs-keyword">do</span> run_to(target_pos);
            status &lt;- <span class="hljs-string">"offside position !"</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((distance_to_ball &lt; <span class="hljs-number">2</span>) <span class="hljs-built_in">and</span> !possess_ball) {
            <span class="hljs-keyword">do</span> try_to_take_ball;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (game.team_possession = team) {
            <span class="hljs-keyword">do</span> offensive_behavior;
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">do</span> defensive_behavior;
        }
    }
    
    <span class="hljs-comment">// defensive behavior, need to be redefined in the strategy file.</span>
    <span class="hljs-comment">// this action is called when the last player who was holding the ball was a player of the ennemy team</span>
    <span class="hljs-built_in">action</span> defensive_behavior virtual:<span class="hljs-literal">true</span> {
        
    }
    <span class="hljs-comment">// defensive behavior, need to be redefined in the strategy file.</span>
    <span class="hljs-comment">// this action is called when the last player who was holding the ball was a player of this team</span>
    <span class="hljs-built_in">action</span> offensive_behavior virtual:<span class="hljs-literal">true</span> {
        
    }
    
    
    <span class="hljs-comment">// ASPECT ////////////////////////////////////////////////////////</span>
    aspect <span class="hljs-built_in">player</span> {
        <span class="hljs-comment">// the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.</span>
        <span class="hljs-keyword">if</span> (possess_ball) {
            draw square(<span class="hljs-number">2</span>) color:(team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) ? game.back_color_team : game.front_color_team;
        }
        <span class="hljs-keyword">else</span> {
            draw circle(<span class="hljs-number">1</span>) color:(team.<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) ? game.back_color_team : game.front_color_team;
        }
    }
}



species base_team {
    <span class="hljs-comment">// ATTRIBUTES ////////////////////////////////////////////////</span>
    
    <span class="hljs-comment">// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE</span>
    float offside_pos &lt;- <span class="hljs-number">0.0</span> update: (<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) ? <span class="hljs-built_in">max</span>((game.players where (each.team != self)) collect (each.location.y))
        : <span class="hljs-built_in">min</span>((game.players where (each.team != self)) collect (each.location.y));
    
    <span class="hljs-comment">// ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)</span>
    string <span class="hljs-built_in">position</span>; <span class="hljs-comment">// can be "front" or "back".</span>
    <span class="hljs-built_in">list</span>&lt;base_player&gt; players; <span class="hljs-comment">// all the players of the team.</span>
    soccer_game game;
    
    base_player closest_player_to_ball &lt;- first(players) update: first( players where (each distance_to each.ball = <span class="hljs-built_in">min</span> (players collect (each distance_to each.ball) ) ) );
    base_player called_player;
    bool possess_ball &lt;- <span class="hljs-literal">false</span>;<span class="hljs-comment">// update: ! empty ( players where (each.possess_ball=true) );</span>
    base_player player_with_ball &lt;- <span class="hljs-literal">nil</span>;<span class="hljs-comment">// update: first(players where (each.possess_ball = true));</span>
    
    <span class="hljs-comment">// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE</span>
    <span class="hljs-built_in">list</span>&lt;point&gt; player_init_position;
}

species ball_sp skills:[moving] {
    <span class="hljs-comment">// The ball agent.</span>
    float <span class="hljs-built_in">speed</span> &lt;- <span class="hljs-number">0.0</span>;
    geometry ball_direction; <span class="hljs-comment">// the direction of the ball is used to be followed by the player</span>
    reflex update {
        <span class="hljs-built_in">speed</span> &lt;- <span class="hljs-built_in">speed</span>*<span class="hljs-number">0.95</span>;
        float future_speed &lt;- <span class="hljs-built_in">speed</span>;
        point tmpPos&lt;-location;
        loop i <span class="hljs-keyword">from</span>:<span class="hljs-number">0</span> <span class="hljs-keyword">to</span>:<span class="hljs-number">10</span> {
            tmpPos &lt;- {tmpPos.x+<span class="hljs-built_in">cos</span>(heading)*<span class="hljs-built_in">speed</span>,tmpPos.y+<span class="hljs-built_in">sin</span>(heading)*<span class="hljs-built_in">speed</span>};
            future_speed &lt;- future_speed*<span class="hljs-number">0.9</span>;
        }
        ball_direction &lt;- line([location,tmpPos]);
        <span class="hljs-keyword">do</span> wander amplitude:<span class="hljs-number">1</span>;
        
        <span class="hljs-comment">// anticipation of the ball position to detect a goal</span>
        <span class="hljs-keyword">if</span> ((location.y+<span class="hljs-built_in">sin</span>(heading)*<span class="hljs-built_in">speed</span>) &gt; <span class="hljs-number">120</span>) {
            write <span class="hljs-string">"back team score a goal !!"</span>;
            ask first(soccer_game) {
                <span class="hljs-keyword">do</span> reinit_phase;
            }
        }
        <span class="hljs-keyword">if</span> ((location.y+<span class="hljs-built_in">sin</span>(heading)*<span class="hljs-built_in">speed</span>) &lt; <span class="hljs-number">0</span>) {
            write <span class="hljs-string">"front team score a goal !!"</span>;
            ask first(soccer_game) {
                <span class="hljs-keyword">do</span> reinit_phase;
            }
        }
    }
    <span class="hljs-built_in">action</span> shooted (point target_position, float speed_atr) {
        <span class="hljs-comment">// action called when a player shoots the ball</span>
        <span class="hljs-built_in">speed</span> &lt;- speed_atr;
        <span class="hljs-keyword">do</span> <span class="hljs-built_in">goto</span> target:target_position;
    }
    
    aspect ball {
        draw circle(<span class="hljs-number">0.5</span>) color:<span class="hljs-meta">#white;</span>
    }
}

species goal_sp {
    string <span class="hljs-built_in">position</span>; <span class="hljs-comment">// can be "front" or "back".</span>
    
    init {
        create goal_keeper <span class="hljs-keyword">with</span>:[<span class="hljs-built_in">position</span>::<span class="hljs-built_in">position</span>];
    }
    
    aspect goal {
        draw rectangle(<span class="hljs-number">7.32</span>,<span class="hljs-number">1.0</span>) color:<span class="hljs-meta">#black;</span>
    }
}

species goal_keeper {
    <span class="hljs-comment">// the goal has a basic behavior : he tries to catch the ball when it is close enough, and when </span>
    string <span class="hljs-built_in">position</span>; <span class="hljs-comment">// can be "front" or "back".</span>
    ball_sp ball &lt;- <span class="hljs-literal">nil</span> update:first(ball_sp);
    
    reflex update when:cycle&gt;<span class="hljs-number">0</span> {
        location &lt;- {ball.location.x/<span class="hljs-number">90</span>*<span class="hljs-number">12</span>+(<span class="hljs-number">90</span>-<span class="hljs-number">12</span>)/<span class="hljs-number">2</span>,location.y};
        <span class="hljs-keyword">if</span> (ball distance_to self &lt; <span class="hljs-number">2</span>) {
            <span class="hljs-keyword">if</span> (flip(<span class="hljs-number">1</span>/(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>*ball.<span class="hljs-built_in">speed</span>))) {
                first(soccer_game).team_possession &lt;- first(first(soccer_game).<span class="hljs-built_in">teams</span> where (each.<span class="hljs-built_in">position</span> = <span class="hljs-built_in">position</span>));
                ask ball {
                    <span class="hljs-keyword">do</span> shooted ({<span class="hljs-number">30</span>+rnd(<span class="hljs-number">30</span>),<span class="hljs-number">60</span>},<span class="hljs-number">5.0</span>);
                }
            }
        }
    }
    
    init {
        location &lt;- {<span class="hljs-number">45</span>,(<span class="hljs-built_in">position</span>=<span class="hljs-string">"front"</span>) ? <span class="hljs-number">117</span> : <span class="hljs-number">3</span>};
    }
    
    <span class="hljs-built_in">action</span> offensive_behavior {
    }
    
    <span class="hljs-built_in">action</span> defensive_behavior {
    }
    
    aspect goal_keeper {
        draw circle(<span class="hljs-number">1</span>) color:(<span class="hljs-built_in">position</span> = <span class="hljs-string">"back"</span>) ? first(soccer_game).back_color_team : first(soccer_game).front_color_team;
    }
}
</code></pre>
<pre><code class="hljs">
model team1strategy

<span class="hljs-keyword">import</span> "./soccer_base.gaml"

species player_intelligentTeam parent:base_player {
    // <span class="hljs-keyword">READ</span> <span class="hljs-keyword">ONLY</span> ATTRIBUTES :
    // position : can be "front" <span class="hljs-keyword">or</span> "back".
    // players : list <span class="hljs-keyword">of</span> <span class="hljs-keyword">all</span> the players <span class="hljs-keyword">of</span> the team.
    // game
    //closest_player_to_ball
    // called_player : the player <span class="hljs-keyword">called</span> <span class="hljs-keyword">for</span> a pass
    // possess_ball : <span class="hljs-keyword">true</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">false</span>
    // player_with_ball : player currently <span class="hljs-keyword">with</span> the ball
    
    // <span class="hljs-keyword">READ</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">WRITE</span> ATTRIBUTES :
    // position_mark
    // status : the <span class="hljs-keyword">current</span> status <span class="hljs-keyword">of</span> the player (can be useful <span class="hljs-keyword">to</span> build the model)
    // influence_area : the area <span class="hljs-keyword">of</span> interest <span class="hljs-keyword">of</span> the player. <span class="hljs-keyword">By</span> <span class="hljs-keyword">default</span>, this area <span class="hljs-keyword">is</span> a <span class="hljs-type">circle</span> <span class="hljs-number">15</span>m diameter centered <span class="hljs-keyword">in</span> the player <span class="hljs-keyword">location</span>.
    
    <span class="hljs-type">float</span> position_mark &lt;- <span class="hljs-number">0.0</span> <span class="hljs-keyword">update</span>: <span class="hljs-keyword">location</span>.y - <span class="hljs-number">20</span>*number_of_ennemy_player_in_range + self.distance_to_closest_ennemy_player;   
    string <span class="hljs-keyword">role</span>; // a <span class="hljs-keyword">value</span> <span class="hljs-keyword">between</span> "defense", "mid" <span class="hljs-keyword">and</span> "attack".
    string wing; // a <span class="hljs-keyword">value</span> <span class="hljs-keyword">between</span> "left", "center" <span class="hljs-keyword">and</span> "right".
    geometry influence_area &lt;- circle(<span class="hljs-number">15</span>,init_pos);
    
    <span class="hljs-type">float</span> defense_mid_pos &lt;- <span class="hljs-number">30.0</span>; // the y percent chosed <span class="hljs-keyword">to</span> separate the defense <span class="hljs-keyword">from</span> the mid position.
    <span class="hljs-type">float</span> mid_attack_pos &lt;- <span class="hljs-number">60.0</span>; // the y percent chosen <span class="hljs-keyword">to</span> separate the mid <span class="hljs-keyword">from</span> the attack position.
    
    init {
        // <span class="hljs-keyword">set</span> the <span class="hljs-keyword">role</span> <span class="hljs-keyword">of</span> the player (<span class="hljs-keyword">between</span> "defense", "mid" <span class="hljs-keyword">and</span> "attack").
        <span class="hljs-keyword">if</span> ( init_pos_in_percent.y &lt; defense_mid_pos ) {
            <span class="hljs-keyword">role</span> &lt;- "defense";
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( (init_pos_in_percent.y &gt; mid_attack_pos ) ) {
            <span class="hljs-keyword">role</span> &lt;- "attack";
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">role</span> &lt;- "mid";
        }
        // <span class="hljs-keyword">set</span> the wing <span class="hljs-keyword">of</span> the player (<span class="hljs-keyword">between</span> "left", "center" <span class="hljs-keyword">and</span> "right")
        <span class="hljs-keyword">if</span> ( init_pos_in_percent.x &lt; <span class="hljs-number">40</span> ) {
            wing &lt;- "left";
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( init_pos_in_percent.x &gt; <span class="hljs-number">60</span> ) {
            wing &lt;- "right";
        }
        <span class="hljs-keyword">else</span> {
            wing &lt;- "center";
        }
    }
    
    action update_influence_area {
        status &lt;- wing + " " + <span class="hljs-keyword">role</span>;
        <span class="hljs-type">float</span> y_ratio;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">role</span> = "defense") { // defense position <span class="hljs-keyword">from</span> <span class="hljs-number">0</span>% <span class="hljs-keyword">to</span> <span class="hljs-number">70</span>% <span class="hljs-keyword">from</span> the own goal, multiplied <span class="hljs-keyword">by</span> the percentage <span class="hljs-keyword">of</span> advancement <span class="hljs-keyword">of</span> the ball
            y_ratio &lt;- <span class="hljs-number">0.7</span> * ball_advancement;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">role</span> = "mid") { // mid position <span class="hljs-keyword">from</span> <span class="hljs-number">15</span>% <span class="hljs-keyword">to</span> <span class="hljs-number">85</span>% <span class="hljs-keyword">from</span> the own goal, multiplied <span class="hljs-keyword">by</span> the percentage <span class="hljs-keyword">of</span> advancement <span class="hljs-keyword">of</span> the ball
            y_ratio &lt;- <span class="hljs-number">0.15</span> + <span class="hljs-number">0.7</span> * ball_advancement;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">role</span> = "attack") { // attack position <span class="hljs-keyword">from</span> <span class="hljs-number">30</span>% <span class="hljs-keyword">to</span> <span class="hljs-number">100</span>% <span class="hljs-keyword">from</span> the own goal, multiplied <span class="hljs-keyword">by</span> the percentage <span class="hljs-keyword">of</span> advancement <span class="hljs-keyword">of</span> the ball
            y_ratio &lt;- <span class="hljs-number">0.3</span> + <span class="hljs-number">0.7</span> * ball_advancement;
        }
        <span class="hljs-type">float</span> x_ratio;
        <span class="hljs-keyword">if</span> (wing = "center") {
            x_ratio &lt;- <span class="hljs-number">0.5</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wing = "left") {
            x_ratio &lt;- <span class="hljs-number">0.5</span> - <span class="hljs-number">0.3</span> * cos( (y_ratio<span class="hljs-number">-0.5</span>)*<span class="hljs-number">120</span> ); // the "side" wings are more marked <span class="hljs-keyword">if</span> the player <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> the center <span class="hljs-keyword">of</span> the field.
        }
        <span class="hljs-keyword">else</span> {
            x_ratio &lt;- <span class="hljs-number">0.5</span> + <span class="hljs-number">0.3</span> * cos( (y_ratio<span class="hljs-number">-0.5</span>)*<span class="hljs-number">120</span> );
        }
        influence_area &lt;- circle(<span class="hljs-number">15</span>,{getXPos(x_ratio),getYPos(y_ratio)});
    }
    
    action defensive_behavior { 
        <span class="hljs-keyword">do</span> update_influence_area;
        // advanced defensive behavior
        // run <span class="hljs-keyword">to</span> the ball <span class="hljs-keyword">if</span> the player <span class="hljs-keyword">is</span> the closest player <span class="hljs-keyword">from</span> the ball.
        <span class="hljs-keyword">if</span> ((self = team.closest_player_to_ball) <span class="hljs-keyword">or</span> (self distance_to ball &lt; <span class="hljs-number">5</span>)) {
            status &lt;- getStatus("run to ball");
            <span class="hljs-keyword">do</span> run_to_ball;
        }
        <span class="hljs-keyword">else</span> {
            // <span class="hljs-keyword">if</span> there <span class="hljs-keyword">is</span> an ennemy player <span class="hljs-keyword">in</span> the influence area, mark the player.
            <span class="hljs-keyword">if</span> ( length(self.ennemy_team.players <span class="hljs-keyword">where</span> (<span class="hljs-keyword">each</span> intersects influence_area)) != <span class="hljs-number">0</span> ) {
                base_player marked_player &lt;- first(<span class="hljs-number">1</span> among (self.ennemy_team.players <span class="hljs-keyword">where</span> (<span class="hljs-keyword">each</span> intersects influence_area)));
                status &lt;- getStatus("mark player "+marked_player);
                <span class="hljs-keyword">do</span> mark_player( marked_player );
            }
            // <span class="hljs-keyword">if</span> there <span class="hljs-keyword">is</span> <span class="hljs-keyword">no</span> ennemy player <span class="hljs-keyword">in</span> the influence area, stay <span class="hljs-keyword">in</span> influence area.
            <span class="hljs-keyword">else</span> {
                status &lt;- getStatus("run to influence area");
                <span class="hljs-keyword">do</span> run_to(influence_area.<span class="hljs-keyword">location</span>);
            }
        }
    }
    
    action offensive_behavior { 
        <span class="hljs-keyword">do</span> update_influence_area;
        // advanced offensive behavior
        <span class="hljs-keyword">if</span> (possess_ball) {
            // <span class="hljs-keyword">if</span> the player has the ball <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">close</span> enough <span class="hljs-keyword">to</span> the ennemy goal, shoot.
            <span class="hljs-keyword">if</span> (distance_to_goal &lt; <span class="hljs-number">35</span> <span class="hljs-keyword">and</span> flip(<span class="hljs-number">1</span>/(<span class="hljs-number">0.1</span>+(self.distance_to_goal/<span class="hljs-number">10</span>)^<span class="hljs-number">2</span>))) {
                status &lt;- getStatus("shoot the ball");
                <span class="hljs-keyword">do</span> shoot;
            }
            // <span class="hljs-keyword">if</span> the player has the ball <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> a safe position, run <span class="hljs-keyword">to</span> the ennemy goal.
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( (position_mark = max( team.players collect (<span class="hljs-keyword">each</span>.position_mark) )) <span class="hljs-keyword">or</span> (distance_to_closest_ennemy_player &gt; <span class="hljs-number">2</span>) )
            {
                status &lt;- getStatus("run to ennemy goal");
                <span class="hljs-keyword">do</span> run_to_ennemy_goal;
            }
            // <span class="hljs-keyword">if</span> the player has the ball but <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> a dangerous situation, pass the ball <span class="hljs-keyword">to</span> another player.
            <span class="hljs-keyword">else</span> {
                base_player target_player &lt;- first(team.players <span class="hljs-keyword">where</span> (<span class="hljs-keyword">each</span>.position_mark = max( team.players collect (<span class="hljs-keyword">each</span>.position_mark)) ) );
                status &lt;- getStatus("pass the ball to "+target_player);
                <span class="hljs-keyword">do</span> pass_the_ball_ahead ( target_player,<span class="hljs-number">10.0</span> );
            }
        }
        // <span class="hljs-keyword">if</span> the player has <span class="hljs-keyword">not</span> the ball but <span class="hljs-keyword">is</span> the <span class="hljs-keyword">called</span> player, run <span class="hljs-keyword">to</span> the ball.
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self = team.called_player) {
            status &lt;- getStatus("run to ball");
            <span class="hljs-keyword">do</span> run_to_ball;
            status &lt;- "called player";
        }
        // <span class="hljs-keyword">else</span>, run <span class="hljs-keyword">to</span> influence area.
        <span class="hljs-keyword">else</span> {
            status &lt;- getStatus("run to influence area");
            <span class="hljs-keyword">do</span> run_to(influence_area.<span class="hljs-keyword">location</span>);
        }
    }
    
    string getStatus(string str) {
        <span class="hljs-keyword">return</span> wing + " " + <span class="hljs-keyword">role</span> + "| action : " + str;
    }
    
}

species intelligentTeam parent:base_team {
    // <span class="hljs-keyword">READ</span> <span class="hljs-keyword">ONLY</span> ATTRIBUTES :
    // position : can be "front" <span class="hljs-keyword">or</span> "back".
    // players : list <span class="hljs-keyword">of</span> <span class="hljs-keyword">all</span> the players <span class="hljs-keyword">of</span> the team.
    // game.
    // closest_player_to_ball.
    // called_player : the player <span class="hljs-keyword">called</span> <span class="hljs-keyword">for</span> a pass.
    // possess_ball : <span class="hljs-keyword">true</span> <span class="hljs-keyword">when</span> a player <span class="hljs-keyword">of</span> the team possess the ball.
    // player_with_ball
    
    // <span class="hljs-keyword">READ</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">WRITE</span> ATTRIBUTES :
    // player_init_position
    
    // initial position <span class="hljs-keyword">of</span> the player <span class="hljs-keyword">in</span> percentage : <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">point</span>,
    //    the first <span class="hljs-keyword">value</span> corresponds <span class="hljs-keyword">to</span> the percentage <span class="hljs-keyword">from</span> left <span class="hljs-keyword">to</span> right (<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> the <span class="hljs-type">point</span> the most <span class="hljs-keyword">in</span> the left side)
    //    the second <span class="hljs-keyword">value</span> corresponds <span class="hljs-keyword">to</span> the percentage <span class="hljs-keyword">from</span> the goal position <span class="hljs-keyword">to</span> the mid position (<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> the goal position)
    list&lt;<span class="hljs-type">point</span>&gt; player_init_position &lt;- [{<span class="hljs-number">20</span>,<span class="hljs-number">20</span>},{<span class="hljs-number">50</span>,<span class="hljs-number">20</span>},{<span class="hljs-number">80</span>,<span class="hljs-number">20</span>},{<span class="hljs-number">30</span>,<span class="hljs-number">50</span>},{<span class="hljs-number">70</span>,<span class="hljs-number">50</span>},{<span class="hljs-number">50</span>,<span class="hljs-number">70</span>},{<span class="hljs-number">30</span>,<span class="hljs-number">90</span>},{<span class="hljs-number">50</span>,<span class="hljs-number">90</span>},{<span class="hljs-number">70</span>,<span class="hljs-number">90</span>}];
}

</code></pre>
<p>Code of the model :</p>
<pre><code class="hljs">
model soccerexpe

<span class="hljs-comment">// import the 2 strategies</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">"./team1_strategy.gaml"</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">"./team2_strategy.gaml"</span>

global {
    <span class="hljs-comment">// set the size of the environment</span>
    geometry shape &lt;- rectangle(<span class="hljs-number">90</span>#m,<span class="hljs-number">120</span>#m);
    
    <span class="hljs-built_in">bool</span> show_info &lt;- <span class="hljs-literal">false</span>;
    
    rgb back_color_team &lt;- #blue;
    rgb front_color_team &lt;- #red;
}

species info_player1 mirrors:player_intelligentTeam {
    <span class="hljs-comment">// mirror species that shows additionnal information about the player</span>
    point location &lt;- target.location update:target.location;
    <span class="hljs-built_in">string</span> status &lt;- target.status update:target.status;
    <span class="hljs-built_in">float</span> speed &lt;- target.speed update:target.speed;
    geometry influence_area &lt;- target.influence_area update:target.influence_area;
    aspect info {
        <span class="hljs-keyword">if</span> (show_info) {
            draw status color:#black;
            draw influence_area color:rgb(<span class="hljs-number">200</span>,<span class="hljs-number">200</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>) border:rgb(<span class="hljs-number">200</span>,<span class="hljs-number">200</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>);
        }
    }
}

species info_player2 mirrors:player_stupidTeam {
    <span class="hljs-comment">// mirror species that shows additionnal information about the player</span>
    point location &lt;- target.location update:target.location;
    <span class="hljs-built_in">string</span> status &lt;- target.status update:target.status;
    <span class="hljs-built_in">float</span> speed &lt;- target.speed update:target.speed;
    geometry influence_area &lt;- target.influence_area update:target.influence_area;
    aspect info {
        <span class="hljs-keyword">if</span> (show_info) {
            draw status color:#black;
            draw influence_area color:rgb(<span class="hljs-number">255</span>,<span class="hljs-number">200</span>,<span class="hljs-number">200</span>,<span class="hljs-number">0</span>) border:rgb(<span class="hljs-number">255</span>,<span class="hljs-number">200</span>,<span class="hljs-number">200</span>,<span class="hljs-number">255</span>);
        }
    }
}

experiment <span class="hljs-built_in">int</span>elligentTeam_vs_stupidTeam type:gui {
    init {
        <span class="hljs-comment">// instantialization of the game (contains global information about the game)</span>
        create soccer_game with:(back_color_team::back_color_team,front_color_team::front_color_team) returns:soccerGame;
        <span class="hljs-comment">// instantialization of the teams</span>
        create <span class="hljs-built_in">int</span>elligentTeam with:(game:first(soccerGame),position:<span class="hljs-string">"back"</span>);
        create stupidTeam with:(game:first(soccerGame),position:<span class="hljs-string">"front"</span>);
        add first(<span class="hljs-built_in">int</span>elligentTeam) to:first(soccerGame).teams;
        add first(stupidTeam) to:first(soccerGame).teams;
        <span class="hljs-comment">// create players of the team1</span>
        list&lt;player_intelligentTeam&gt; player_list1;
        loop pos over:first(<span class="hljs-built_in">int</span>elligentTeam).player_init_position {
            <span class="hljs-comment">// compute the "real position" of each player according to the percentage given in "player_init_position"</span>
            point real_pos &lt;- (first(<span class="hljs-built_in">int</span>elligentTeam).position = <span class="hljs-string">"back"</span>) ? {<span class="hljs-number">90</span>-pos.x/<span class="hljs-number">100</span>*<span class="hljs-number">90</span>,pos.y/<span class="hljs-number">100</span>*<span class="hljs-number">60</span>} : {pos.x/<span class="hljs-number">100</span>*<span class="hljs-number">90</span>,<span class="hljs-number">120</span>-pos.y/<span class="hljs-number">100</span>*<span class="hljs-number">60</span>};
            create player_intelligentTeam with:(team:first(<span class="hljs-built_in">int</span>elligentTeam),game:first(<span class="hljs-built_in">int</span>elligentTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;
            add first(pl) to:player_list1;
        }
        first(<span class="hljs-built_in">int</span>elligentTeam).players &lt;- player_list1;
        <span class="hljs-comment">// create players of the team2</span>
        list&lt;player_stupidTeam&gt; player_list2;
        loop pos over:first(stupidTeam).player_init_position {
            <span class="hljs-comment">// compute the "real position" of each player according to the percentage given in "player_init_position"</span>
            point real_pos &lt;- (first(stupidTeam).position = <span class="hljs-string">"back"</span>) ? {<span class="hljs-number">90</span>-pos.x/<span class="hljs-number">100</span>*<span class="hljs-number">90</span>,pos.y/<span class="hljs-number">100</span>*<span class="hljs-number">60</span>} : {pos.x/<span class="hljs-number">100</span>*<span class="hljs-number">90</span>,<span class="hljs-number">120</span>-pos.y/<span class="hljs-number">100</span>*<span class="hljs-number">60</span>};
            create player_stupidTeam with:(team:first(stupidTeam),game:first(stupidTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;
            add first(pl) to:player_list2;
        }
        first(stupidTeam).players &lt;- player_list2;
        first(soccerGame).players &lt;- player_list1+player_list2;
    }
    parameter <span class="hljs-string">"show player info"</span> var:show_info;
    output {
        display <span class="hljs-string">"soccer_field"</span>  {
            <span class="hljs-comment">// display the field.</span>
            image <span class="hljs-string">"../images/soccer_field2.png"</span>;
            <span class="hljs-comment">// display the species with their correct aspect</span>
            species player_intelligentTeam aspect:player;
            species player_stupidTeam aspect:player;
            species ball_sp aspect:ball;
            species goal_sp aspect:goal;
            species goal_keeper aspect:goal_keeper;
            species info_player1 aspect:info;
            species info_player2 aspect:info;
        }
    }
}

experiment <span class="hljs-built_in">int</span>elligentTeam_vs_intelligentTeam type:gui {
    init {
        <span class="hljs-comment">// instantialization of the game (contains global information about the game)</span>
        create soccer_game with:(back_color_team::back_color_team,front_color_team::front_color_team) returns:soccerGame;
        <span class="hljs-comment">// instantialization of the teams</span>
        create <span class="hljs-built_in">int</span>elligentTeam with:(game:first(soccerGame),position:<span class="hljs-string">"back"</span>) returns:backTeam;
        create <span class="hljs-built_in">int</span>elligentTeam with:(game:first(soccerGame),position:<span class="hljs-string">"front"</span>) returns:frontTeam;
        
        add first(backTeam) to:first(soccerGame).teams;
        add first(frontTeam) to:first(soccerGame).teams;
        <span class="hljs-comment">// create players of the team1</span>
        list&lt;player_intelligentTeam&gt; player_list1;
        loop pos over:first(backTeam).player_init_position {
            <span class="hljs-comment">// compute the "real position" of each player according to the percentage given in "player_init_position"</span>
            point real_pos &lt;- (first(backTeam).position = <span class="hljs-string">"back"</span>) ? {<span class="hljs-number">90</span>-pos.x/<span class="hljs-number">100</span>*<span class="hljs-number">90</span>,pos.y/<span class="hljs-number">100</span>*<span class="hljs-number">60</span>} : {pos.x/<span class="hljs-number">100</span>*<span class="hljs-number">90</span>,<span class="hljs-number">120</span>-pos.y/<span class="hljs-number">100</span>*<span class="hljs-number">60</span>};
            create player_intelligentTeam with:(team:first(backTeam),game:first(backTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;
            add first(pl) to:player_list1;
        }
        first(backTeam).players &lt;- player_list1;
        <span class="hljs-comment">// create players of the team2</span>
        list&lt;player_intelligentTeam&gt; player_list2;
        loop pos over:first(frontTeam).player_init_position {
            <span class="hljs-comment">// compute the "real position" of each player according to the percentage given in "player_init_position"</span>
            point real_pos &lt;- (first(frontTeam).position = <span class="hljs-string">"back"</span>) ? {<span class="hljs-number">90</span>-pos.x/<span class="hljs-number">100</span>*<span class="hljs-number">90</span>,pos.y/<span class="hljs-number">100</span>*<span class="hljs-number">60</span>} : {pos.x/<span class="hljs-number">100</span>*<span class="hljs-number">90</span>,<span class="hljs-number">120</span>-pos.y/<span class="hljs-number">100</span>*<span class="hljs-number">60</span>};
            create player_intelligentTeam with:(team:first(frontTeam),game:first(frontTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;
            add first(pl) to:player_list2;
        }
        first(frontTeam).players &lt;- player_list2;
        first(soccerGame).players &lt;- player_list1+player_list2;
    }
    parameter <span class="hljs-string">"show player info"</span> var:show_info;
    output {
        display <span class="hljs-string">"soccer_field"</span>  {
            <span class="hljs-comment">// display the field.</span>
            image <span class="hljs-string">"../images/soccer_field2.png"</span>;
            <span class="hljs-comment">// display the species with their correct aspect</span>
            species player_intelligentTeam aspect:player;
            species ball_sp aspect:ball;
            species goal_sp aspect:goal;
            species goal_keeper aspect:goal_keeper;
            species info_player1 aspect:info;
            species info_player2 aspect:info;
        }
    }
}
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/BC2019-Gama-Site/" class="nav-home"><img src="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png" alt="GAMA-Platform" width="66" height="58"/></a><div><h5>Docs</h5><a href="/BC2019-Gama-Site/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/BC2019-Gama-Site/docs/en/doc2.html">Guides (or other categories)</a><a href="/BC2019-Gama-Site/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/BC2019-Gama-Site/en/users.html">User Showcase</a><a href="http://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/BC2019-Gama-Site/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2019 GAMA-Platform</section></footer></div></body></html>