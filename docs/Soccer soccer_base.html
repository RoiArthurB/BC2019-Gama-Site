<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Soccer soccer_base · GAMA-Platform</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="GAMA, modeling made easy"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Soccer soccer_base · GAMA-Platform"/><meta property="og:type" content="website"/><meta property="og:url" content="https://roiarthurb.github.io/BC2019-Gama-Site/"/><meta property="og:description" content="GAMA, modeling made easy"/><meta property="og:image" content="https://roiarthurb.github.io/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://roiarthurb.github.io/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><link rel="shortcut icon" href="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/atom.xml" title="GAMA-Platform Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://roiarthurb.github.io/BC2019-Gama-Site/blog/feed.xml" title="GAMA-Platform Blog RSS Feed"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js" async=""></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js" async=""></script><script type="text/javascript" src="/BC2019-Gama-Site/js/code-block-buttons.js" async=""></script><link rel="stylesheet" href="/BC2019-Gama-Site/css/main.css"/><script src="/BC2019-Gama-Site/js/codetabs.js"></script></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/BC2019-Gama-Site/"><img class="logo" src="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png" alt="GAMA-Platform"/><h2 class="headerTitleWithLogo">GAMA-Platform</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/BC2019-Gama-Site/docs/Home" target="_self">Docs</a></li><li class=""><a href="/BC2019-Gama-Site/help" target="_self">Help</a></li><li class=""><a href="/BC2019-Gama-Site/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Soccer soccer_base</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="_soccerbase"></a><a href="#_soccerbase" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>_soccerbase</h1>
<p><em>Author : Julien</em></p>
<p>This model contains the parent classes of the model</p>
<p>Code of the model :</p>
<pre><code class="hljs">
model soccerbase

species soccer_game {
    // contains the global informations of the game
    rgb back_color_team;
    rgb front_color_team;
    
    ball_sp ball; // the ball agent
    goal_sp front_goal; // contains the goal at the front of the field (y = 120)
    goal_sp back_goal; // contains the goal at the back of the field (y = 0)
    list&lt;base_team&gt; teams; // contains the 2 teams
    list&lt;base_player&gt; players; // contains all the players of the game
    
    base_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.
    
    init {
        // create the entities ball and the 2 goals
        create ball_sp with:[location::world.location] returns:var_ball;
        ball &lt;- first(var_ball);
        create goal_sp with:[location::{world.location.x,120},position::"front"] returns:var_goal1;
        front_goal &lt;- first(var_goal1);
        create goal_sp with:[location::{world.location.x,0},position::"back"] returns:var_goal2;
        back_goal &lt;- first(var_goal2);
    }
    
    action reinit_phase {
        // this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center
        ask players {
            location &lt;- init_pos;
            previous_pos &lt;- init_pos;
        }
        ball.location &lt;- world.location;
        ball.destination &lt;- world.location;
        ball.speed &lt;- 0.0;
    }
}

species base_player skills:[moving] {
    // ATTRIBUTES ////////////////////////////////////////////////
    
    // ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE
    float recuperation_ability &lt;- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it
    float speed_without_ball;
    float speed_with_ball;
    point previous_pos; // used to apply inertia
    bool displacement_effectued&lt;-false update:false; // we can apply only one displacement by step !
    
    // ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)
    base_team team;
    soccer_game game;
    base_team ennemy_team &lt;- nil update:first(game.teams where (each.position != team.position));
    ball_sp ball &lt;- nil update:first(ball_sp);
    goal_sp own_goal &lt;- nil update:first(goal_sp where (each.position = team.position));
    goal_sp ennemy_goal &lt;- nil update:first(goal_sp where (each.position != team.position));
    // ratio of avancement of the ball (from the point of view of the current team)
    float ball_advancement &lt;- 0.0 update:(team.position = "back") ? ball.location.y / 120 : 1 - ball.location.y / 120;
    
    bool possess_ball;
    point init_pos;
    point init_pos_in_percent;
    float distance_to_closest_ennemy_player &lt;- 100.0 update:self distance_to closest_ennemy_player;
    // the number of ennemy players in a range of 15 meters
    int number_of_ennemy_player_in_range &lt;- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true));
    float distance_to_ball &lt;- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball;
    float distance_to_goal &lt;- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal;
    // the closest player of this team
    base_player closest_friend_player &lt;- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self)) 
        where (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) ) 
    );
    // the closest ennemy player
    base_player closest_ennemy_player &lt;- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self)) 
        where (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) ) 
    );
    // the player of this team wich has the best "position_mark"
    base_player best_position_player &lt;- nil update:first((team.players where (each != self)) 
        where (each.position_mark = max((team.players where (each != self)) collect (each.position_mark)))
    );
    float current_speed&lt;-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;
    
    // ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE
    float position_mark &lt;- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is). 
    // By default, this mark is equal to -distance_to_goal.
    string status &lt;- ""; // the current status of the player (can be useful to build the model)
    geometry influence_area &lt;- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.

    
    // CONSTRUCTOR /////////////////////////////////////////////
    init {
        init_pos &lt;- location;
        previous_pos &lt;- location;
        possess_ball &lt;- false;
        speed_with_ball &lt;- 0.4;
        speed_without_ball &lt;- 0.5;
    }
    
    // ACTIONS ////////////////////////////////////////////////////
    
    // ACTIONS TO CALL FROM THE STRATEGY FILE
    // action to run to a particular position
    action run_to(point target) {
        if (!displacement_effectued) {
                do goto target:target speed:current_speed;
            if (possess_ball) {
                ball.location &lt;- location;
            }
            displacement_effectued &lt;- true;
        }
        else {
            write "WARNING : only ONE action of displacement is allowed each step";
        }
    }
    
    // action to run to the ball
    action run_to_ball {
        point targetPos;
        if (ball.ball_direction intersects circle(1)) {
            targetPos &lt;- ball.location;
        }
        else {
            targetPos &lt;- (ball.ball_direction closest_points_with self) at 0;
        }
        do run_to(targetPos);
    }
    
    // action to run to the ennemy goal
    action run_to_ennemy_goal {
        do run_to( ennemy_goal.location );
    }
    
    // action to run to its own goal
    action run_to_own_goal {
        do run_to( own_goal.location );
    }
    
    // action to mark a player
    action mark_player (base_player player) {
        float rnd_area &lt;- 4.0; // the player will choose a position in a square of rnd_area m.
        point pos &lt;- (team.position = "front") ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};
        do run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} );
    }
    
    // action ot shoot the ball to the ennemy goal
    action shoot {
        do loose_ball;
        ask ball {
            do shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;
        }
    }
    
    // action to pass the ball to an ally
    action pass_the_ball (base_player target_player) {
        do loose_ball;
        ask ball {
            do shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;
        }
        team.called_player &lt;- target_player;
    }
    
    // action to pass the ball to an ally
    action pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {
        do loose_ball;
        ask ball {
            float offset &lt;- ((myself.team.position = "back") ? number_of_meter_ahead : -number_of_meter_ahead);
            point target_point &lt;- {target_player.location.x,target_player.location.y+offset};
            do shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;
        }
        team.called_player &lt;- target_player;
    }
    
    // ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE
    // try to take the ball if it is close enough
    action try_to_take_ball {
        // if no player has the ball
        if (!team.possess_ball and !ennemy_team.possess_ball) {
            // if the player is the one called (result of a pass)
            if (team.called_player = self) {
                do take_ball;
            }
            // if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball
            else {
                if (flip(1/(1+2*ball.speed))) {
                    do take_ball;
                }
            }
        }
        // the ball is possessed by the ennemy team
        else if (ennemy_team.possess_ball) {
            // try to catch the ball from the other player
            if flip(recuperation_ability) {
                do take_ball;
            }
        }
    }
    
    // action of taking the ball
    action take_ball {
        if (ennemy_team.possess_ball) {
            ask ennemy_team.player_with_ball {
                do loose_ball;
            }
        }
        possess_ball &lt;- true;
        ball.speed &lt;- 0.0;
        ball.destination &lt;- ball.location;
        team.called_player &lt;- nil;
        team.player_with_ball &lt;- self;
        team.possess_ball &lt;- true;
        game.team_possession &lt;- team;
    }
    
    // action of loosing the ball
    action loose_ball {
        possess_ball &lt;- false;
        team.player_with_ball &lt;- nil;
        team.possess_ball &lt;- false;
    }
    
    // apply the inertia
    action apply_inertia {
        point prev_pos &lt;- location;
        point inertia_vect &lt;- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};
        float max_inertia &lt;- current_speed;
        if (norm(inertia_vect) &gt; max_inertia) {
            float inertia_x &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));
            float inertia_y &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));
            inertia_x &lt;- (inertia_vect.x &lt; 0) ? -inertia_x : inertia_x;
            inertia_y &lt;- (inertia_vect.y &lt; 0) ? -inertia_y : inertia_y;
            inertia_vect &lt;- {inertia_x,inertia_y};
        }
        location &lt;- location + inertia_vect;
        previous_pos &lt;- prev_pos;
    }
    
    // useful functions
    // this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point.
    float getXPos(float x_ratio) {
        float result;
        if (team.position="back") {
            result &lt;- 90-x_ratio*90;
        }
        else {
            result &lt;- x_ratio*90;
        }
        return result;
    }
    
    // this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point.
    float getYPos(float y_ratio) {
        float result;
        if (team.position="back") {
            result &lt;- y_ratio*120;
        }
        else {
            result &lt;- 120-y_ratio*120;
        }
        return result;
    }
    
    ///////////////////////////////////////////////////////
    
    // The update function, calls the adequate behavior
    reflex update when:cycle&gt;1 {
        do apply_inertia;
        // verify if it is a non-offside position
        if ( (((team.position = "back") and (location.y &gt; team.offside_pos))
            or ((team.position = "front") and (location.y &lt; team.offside_pos))) 
            and (!possess_ball) and (self != team.called_player)
        ) {
            // offside position, go back to a correct position
            point target_pos &lt;- {location.x,(team.position = "back") ? location.y-current_speed:location.y+current_speed};
            do run_to(target_pos);
            status &lt;- "offside position !";
        }
        else if ((distance_to_ball &lt; 2) and !possess_ball) {
            do try_to_take_ball;
        }
        else if (game.team_possession = team) {
            do offensive_behavior;
        }
        else {
            do defensive_behavior;
        }
    }
    
    // defensive behavior, need to be redefined in the strategy file.
    // this action is called when the last player who was holding the ball was a player of the ennemy team
    action defensive_behavior virtual:true {
        
    }
    // defensive behavior, need to be redefined in the strategy file.
    // this action is called when the last player who was holding the ball was a player of this team
    action offensive_behavior virtual:true {
        
    }
    
    
    // ASPECT ////////////////////////////////////////////////////////
    aspect player {
        // the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.
        if (possess_ball) {
            draw square(2) color:(team.position = "back") ? game.back_color_team : game.front_color_team;
        }
        else {
            draw circle(1) color:(team.position = "back") ? game.back_color_team : game.front_color_team;
        }
    }
}



species base_team {
    // ATTRIBUTES ////////////////////////////////////////////////
    
    // ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE
    float offside_pos &lt;- 0.0 update: (position = "back") ? max((game.players where (each.team != self)) collect (each.location.y))
        : min((game.players where (each.team != self)) collect (each.location.y));
    
    // ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)
    string position; // can be "front" or "back".
    list&lt;base_player&gt; players; // all the players of the team.
    soccer_game game;
    
    base_player closest_player_to_ball &lt;- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) );
    base_player called_player;
    bool possess_ball &lt;- false;// update: ! empty ( players where (each.possess_ball=true) );
    base_player player_with_ball &lt;- nil;// update: first(players where (each.possess_ball = true));
    
    // ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE
    list&lt;point&gt; player_init_position;
}

species ball_sp skills:[moving] {
    // The ball agent.
    float speed &lt;- 0.0;
    geometry ball_direction; // the direction of the ball is used to be followed by the player
    reflex update {
        speed &lt;- speed*0.95;
        float future_speed &lt;- speed;
        point tmpPos&lt;-location;
        loop i from:0 to:10 {
            tmpPos &lt;- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};
            future_speed &lt;- future_speed*0.9;
        }
        ball_direction &lt;- line([location,tmpPos]);
        do wander amplitude:1;
        
        // anticipation of the ball position to detect a goal
        if ((location.y+sin(heading)*speed) &gt; 120) {
            write "back team score a goal !!";
            ask first(soccer_game) {
                do reinit_phase;
            }
        }
        if ((location.y+sin(heading)*speed) &lt; 0) {
            write "front team score a goal !!";
            ask first(soccer_game) {
                do reinit_phase;
            }
        }
    }
    action shooted (point target_position, float speed_atr) {
        // action called when a player shoots the ball
        speed &lt;- speed_atr;
        do goto target:target_position;
    }
    
    aspect ball {
        draw circle(0.5) color:#white;
    }
}

species goal_sp {
    string position; // can be "front" or "back".
    
    init {
        create goal_keeper with:[position::position];
    }
    
    aspect goal {
        draw rectangle(7.32,1.0) color:#black;
    }
}

species goal_keeper {
    // the goal has a basic behavior : he tries to catch the ball when it is close enough, and when 
    string position; // can be "front" or "back".
    ball_sp ball &lt;- nil update:first(ball_sp);
    
    reflex update when:cycle&gt;0 {
        location &lt;- {ball.location.x/90*12+(90-12)/2,location.y};
        if (ball distance_to self &lt; 2) {
            if (flip(1/(1+2*ball.speed))) {
                first(soccer_game).team_possession &lt;- first(first(soccer_game).teams where (each.position = position));
                ask ball {
                    do shooted ({30+rnd(30),60},5.0);
                }
            }
        }
    }
    
    init {
        location &lt;- {45,(position="front") ? 117 : 3};
    }
    
    action offensive_behavior {
    }
    
    action defensive_behavior {
    }
    
    aspect goal_keeper {
        draw circle(1) color:(position = "back") ? first(soccer_game).back_color_team : first(soccer_game).front_color_team;
    }
}
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/BC2019-Gama-Site/" class="nav-home"><img src="/BC2019-Gama-Site/resources/images/general/GamaPlatform.png" alt="GAMA-Platform" width="66" height="58"/></a><div><h5>Docs</h5><a href="/BC2019-Gama-Site/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/BC2019-Gama-Site/docs/en/doc2.html">Guides (or other categories)</a><a href="/BC2019-Gama-Site/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/BC2019-Gama-Site/en/users.html">User Showcase</a><a href="http://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/BC2019-Gama-Site/blog">Blog</a><a href="https://github.com/">GitHub</a></div></section><section class="copyright">Copyright © 2019 GAMA-Platform</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0f9f28b9ab9efae89810921a351753b5',
                indexName: 'github',
                inputSelector: '#search_input_react'
              });
            </script></body></html>