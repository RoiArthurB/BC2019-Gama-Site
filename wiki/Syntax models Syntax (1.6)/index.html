<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Syntax · GAMA-Platform</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="GAMA"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Syntax · GAMA-Platform"/><meta property="og:type" content="website"/><meta property="og:url" content="https://roiarthurb.github.io/BC2019-Gama-Site/"/><meta property="og:description" content="GAMA"/><meta property="og:image" content="https://roiarthurb.github.io/BC2019-Gama-Site//resources/images/general/GamaPlatform.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://roiarthurb.github.io/BC2019-Gama-Site//resources/images/general/GamaPlatform.png"/><link rel="shortcut icon" href="/BC2019-Gama-Site//img/gama-logo.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js" async=""></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js" async=""></script><script type="text/javascript" src="/BC2019-Gama-Site/js/code-block-buttons.js" async=""></script><link rel="stylesheet" href="/BC2019-Gama-Site/css/main.css"/><script src="/BC2019-Gama-Site/js/codetabs.js"></script></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/BC2019-Gama-Site/"><img class="logo" src="/BC2019-Gama-Site//img/gama-logo_white.png" alt="GAMA-Platform"/><h2 class="headerTitleWithLogo">GAMA-Platform</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/BC2019-Gama-Site/wiki/Home" target="_self">Documentation</a></li><li class=""><a href="/BC2019-Gama-Site/wiki/Tutorials" target="_self">Tutorials</a></li><li class=""><a href="/BC2019-Gama-Site/help" target="_self">Download</a></li><li class=""><a href="/BC2019-Gama-Site/wiki/Contribute" target="_self">Contribute</a></li><li class=""><a target="_self"></a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Syntax</h1></header><article><div><span><p><em>Author : Alexis Drogoul</em></p>
<p>An overview of the new syntactic constructs that have been introduced in GAMA 1.6</p>
<p>Code of the model :</p>
<pre><code class="hljs">
@no_warning
model syntax

<span class="hljs-comment">/**
 * The global section can now sport skills and control, just like other agents. 
 * The example below shows a potentially moving world that can be controlled by a finite state machine.
 */</span>
global skills: [moving] control: fsm {

<span class="hljs-comment">/**
 * EQUATIONS
 */</span> 
    float x;
    float y;
    float t;
    equation eq {
        diff(x, t) = x / 2;
        diff(y, t) = x + y * 2;
    }

    reflex solving {solve eq step: 1 method: rk4;}

    <span class="hljs-comment">/** 
 * ATTRIBUTES
 */</span>

<span class="hljs-comment">// Attributes can be declared in different ways, ranging from "classic"...</span>
    list&lt;int&gt; a1 const: true &lt;- [1, 2, 3] of: int;
    list a2 &lt;- [1, 2, 3] of: int;
    <span class="hljs-comment">// ... to "compact" Java-like syntax.</span>
    list&lt;int&gt; a3 &lt;- [1, 2, 3];

    <span class="hljs-comment">// The declaration of a default size/value in containers is now working correctly</span>
    list&lt;float&gt; f &lt;- list_with(2000,0.0);

    <span class="hljs-comment">// Functions can be declared using the regular facet "-&gt;" / "function:" </span>
    int b1 -&gt; { 100 + length(a1) };
    int b2 function: { 100 + length(a1) };
    <span class="hljs-comment">// ... or using a block (like a statement -- note the absence of semi-column at the end)</span>
    int b3 {
        100 + length(a1)
    }
    state first_state initial: true {
    <span class="hljs-comment">//...</span>

    }
    init {
        create species0 number: 20;
    }
    

    <span class="hljs-comment">/**
     * UNITS
     */</span>
<span class="hljs-comment">// The usage of units is improved ( "#" being replaced by "°"), and they can be combined</span>
    float c &lt;- 10 °meter;
    float speed &lt;- 10 °meter / °sec;

    <span class="hljs-comment">// Attributes can (finally!) be named after unit names</span>
    float meter &lt;- 10.0;

    <span class="hljs-comment">// Some mathematical constants have been introduced alongside units</span>
    float pi_4 &lt;- °pi / 4;
    float e &lt;- °e;

    <span class="hljs-comment">/**
      * ACTIONS
      */</span>
    <span class="hljs-comment">// Actions can also be declared in different ways. Classic:</span>
    action dummy1 type: list of: int {
        arg a type: int default: 100;
        arg b type: float;
        return [a, int(b)];
    }
    <span class="hljs-comment">// Semi-classic (prefixed by the type)</span>
    list dummy2 of: int {
        arg a type: int default: 100;
        arg b type: float;
        return [a, int(b)];
    }
    <span class="hljs-comment">//Compact</span>
    list&lt;int&gt; dummy1 (int a &lt;- 100, float b) {
        return [a, int(b)];
    }

    <span class="hljs-comment">// An action that returns nothing can still be called "action"</span>
    action dummy_void {
        <span class="hljs-statement">write</span> <span class="hljs-string">"dummy_void"</span>;
    }

    <span class="hljs-comment">/**
     * DEALING WITH VARIABLES
     */</span>
    reflex variables {

    <span class="hljs-comment">// Temporary variables can use the same syntax as attributes. The classic form:</span>
        <span class="hljs-comment">//let name: t1 type: int value: length(a1);</span>
        <span class="hljs-comment">// is equivalent to the more compact one:</span>
        int t2 &lt;- length(a1);

        <span class="hljs-comment">// Assigning a value to variables is also sporting a new syntax </span>
        set t2 value: 100;
        <span class="hljs-comment">// ... can be replaced by </span>
        set t2 &lt;- 100;
        <span class="hljs-comment">// ... or even by</span>
        t2 &lt;- 100;

        <span class="hljs-comment">// Species can now act as direct containers of their agents..</span>
        list&lt;species0&gt; spec_with_location &lt;- species0 select (each.location = { 0, 0 });
        species0 agent0 &lt;- species0[10];
        <span class="hljs-statement">write</span> string(agent0);

        <span class="hljs-comment">// ...  and agents as direct containers of their attributes (mimicking the internal attributes map). This "virtual map" will now contain, in addition to the attributes, </span>
        <span class="hljs-comment">// all the variables loaded from CSV, SQL or shape files (some stored in the agent itself, others in the shape).</span>
        agent0[<span class="hljs-string">"departure"</span>] &lt;- { 0, 0 };
        <span class="hljs-statement">write</span> string(agent0);

        <span class="hljs-comment">// Keys are not necessarily strings, by the way ! A warning is emitted in such cases, but it is just a warning.</span>
        agent0[0] &lt;- 0;

        <span class="hljs-comment">// Accesses can be combined</span>
        species0[10].name &lt;- <span class="hljs-string">"A new name"</span>; <span class="hljs-comment">// which is equivalent to (spec at 10).name = "A new name";</span>

        <span class="hljs-comment">// Points can be used (with or without curly parentheses) to access agents in species</span>
        species0 agent1 &lt;- species0[10, 10]; <span class="hljs-comment">// returns the agent closest to point {10,10} for a "regular" species</span>
        <span class="hljs-comment">// The behavior is a bit tweaked for grids, to allow for a "natural" access</span>
        my_grid cell0 &lt;- my_grid[10, 10]; <span class="hljs-comment">// Here, it is the cell at {10, 10} in the matrix of cells</span>

        <span class="hljs-comment">// Shapes also act as containers of CVS/Shapefile attributes (in case they are loaded without being attributed to an agent), as well as 3D properties (for the display).</span>
        agent0.name &lt;- string(agent0.shape[<span class="hljs-string">"ID"</span>]);
        geometry geom &lt;- square(100);
        geom[<span class="hljs-string">"type"</span>] &lt;- <span class="hljs-string">"cube"</span>;
        
        
        <span class="hljs-comment">// All these attributes can be accessed using the casting of agents to map</span>
        <span class="hljs-statement">write</span> string(map(agent0));

        <span class="hljs-comment">//This access can be used everywhere, easing the use of shape files (and data files in general)</span>
        list&lt;geometry&gt; shapes &lt;- list&lt;geometry&gt;(file(<span class="hljs-string">"something.shp"</span>));

        <span class="hljs-comment">// If we suppose val1, val2, etc. are defined in the shape file</span>
        float max &lt;- min(shapes collect float(each[<span class="hljs-string">"val1"</span>]));

        <span class="hljs-comment">//To allow for an easier access in case the modeler only uses agents, agents' attributes can "pass through" towards their shape's attributes </span>
        <span class="hljs-comment">//(in case the same attribute has not been defined in the agent, of course)</span>
        create species0 from: shapes;
        max &lt;- min(species0 collect float(each[<span class="hljs-string">"val1"</span>])); <span class="hljs-comment">// equivalent to each.shape["val1"]. </span>
        <span class="hljs-comment">//This last sentence only works, however, for *reading* values.</span>
        any(species0)[<span class="hljs-string">"val1"</span>] &lt;- 100; <span class="hljs-comment">// will result in the creation of a new attribute in the agent (not in its shape)</span>
        any(species0).shape[<span class="hljs-string">"val1"</span>] &lt;- 100; <span class="hljs-comment">// will be correct in that case</span>

        <span class="hljs-comment">// Container variables have seen their usability clearly improved </span>
        map m &lt;- map([]);
        list&lt;int&gt; l &lt;- [1, 2, 3, 4, 5];

        <span class="hljs-comment">// Adding a value</span>
        add 1 to: l;
        <span class="hljs-comment">// ... can now be written</span>
        l &lt;+ 1;

        <span class="hljs-comment">// Removing a value</span>
        remove 1 from: l;
        remove <span class="hljs-string">"type"</span> from: geom;

        <span class="hljs-comment">// ... can now be written</span>
        l &gt;- 1;
        geom &gt;- <span class="hljs-string">"type"</span>;
        any(species0)[] &gt;- <span class="hljs-string">"name"</span>; <span class="hljs-comment">// removes the "name" attribute from a random agent. Can be dangerous in some cases... </span>

        <span class="hljs-comment">// Setting/putting a value</span>
        put <span class="hljs-string">"a"</span> at: <span class="hljs-string">'key'</span> in: m;
        put 1 at: 0 in: l;
        <span class="hljs-comment">// ... can now be written</span>
        m[<span class="hljs-string">'key'</span>] &lt;- <span class="hljs-string">"a"</span>;
        l[0] &lt;- 1;
        list&lt;list&gt; ll &lt;- [];
        ll &lt;+ []; <span class="hljs-comment">// [[]]</span>
        ll[0] &lt;+ 10; <span class="hljs-comment">// [[10]]</span>

    }

    <span class="hljs-comment">// TODO Species can now be written within the "global" section (to enforce the idea that the top-level species are indeed contained in the world)</span>
    species inside_global {
    }

    <span class="hljs-comment">/**
      * INVOCATION OF ACTIONS
      */</span>
    reflex calling_actions {
    <span class="hljs-comment">// IN IMPERATIVE MODE (i.e. in a statement)</span>
    <span class="hljs-comment">// The classic way</span>
        do dummy1 with: [a::10, b::100.0];

        <span class="hljs-comment">// Another by distributing the arguments</span>
        do dummy1 a: 10 b: 100.0;

        <span class="hljs-comment">// The new alternative one </span>
        do dummy1(a: 10, b: 100.0);
        ask any(species1) {
            do goto(target: { 10, 10 }, speed: 100);
        }
        <span class="hljs-comment">// ... which has been introduced to unify the functional/imperative use of actions.</span>

        <span class="hljs-comment">// And finally the new functional way, probably reserved to simple calls (as all the arguments must be passed).</span>
        do dummy1(10, 100.0);

        <span class="hljs-comment">// IN FUNCTIONAL MODE (i.e. as part of expressions)</span>
        <span class="hljs-comment">// The "classic" way of calling actions. Note that in that case, dummy1 is used like a binary operator (callee on the left, argument map on the right)</span>
        list d1 &lt;- self dummy1 [a::10, b::100.0];

        <span class="hljs-comment">// First improvement, argument maps can now be simplified, which results in a functional syntax with named arguments</span>
        list d2 &lt;- self dummy1 (b: 100.0); <span class="hljs-comment">// a is not passed as it has a default value.</span>

        <span class="hljs-comment">// To improve the readability of this way of calling actions, the dotted notation is now allowed as well </span>
        list d3 &lt;- self.dummy1(a: 100, b: 100.0);
        float s &lt;- any(species1).compute_speed_using_an_action(max: 100);

        <span class="hljs-comment">// Finally, the functional syntax is also introduced. In that case, all the arguments need to be passed as they are not named.</span>
        <span class="hljs-comment">// This unifies the way of calling operators and actions furthermore. </span>

        <span class="hljs-comment">// The action can be called as a n_ary operator, and in that case, the callee is implicitely the agent that executes the call</span>
        list d4 &lt;- dummy1(10, 100.0);

        <span class="hljs-comment">// And it can also be called using the "dotted" syntax, in which case the callee needs to be explicit (can be "self" of course)</span>
        path p &lt;- world.move(100, 45, shape); <span class="hljs-comment">// speed, heading, bounds</span>


        <span class="hljs-comment">/**
         *  As a summary, the syntaxes kept for future developments of models will likely be: 
         */</span>

<span class="hljs-comment">// CALLING WITH NAMED ARGUMENTS + OPTIONAL DOTTED SYNTAX IN EXPRESSIONS + IMPLICIT CALLEE IN CASE OF SELF</span>
        <span class="hljs-comment">// This method is convenient as it allows to pass only some arguments (if defaults are defined, which is implicitely the case in primitives), </span>
        <span class="hljs-comment">// but also to pass them in any order</span>
        do wander(speed: 100, amplitude: 10);
        path p1 &lt;- path(self.wander(amplitude: 10, speed: 100));
        path p2 &lt;- path(self wander (speed: 100, bounds: square(10)));
        path p3 &lt;- path(wander(speed: 100));
        path p4 &lt;- path(wander());

        <span class="hljs-comment">// CALLING WITH COMPLETE ARGUMENTS + OPTIONAL DOTTED SYNTAX IN EXPRESSIONS + IMPLICIT CALLEE IN CASE OF SELF</span>
        <span class="hljs-comment">// This method is convenient as it follows the functional syntax of operators and then allows to declare "quasi-operators" in species, even to redefine existing ones.</span>
        do wander(100, 100, self.shape); <span class="hljs-comment">// speed, amplitude, bounds as defined in primitive wander</span>
        int d5 &lt;- self.max(10, 100);
        int d6 &lt;- self max (10, 100);
        int d7 &lt;- max(10, 100);
        list others &lt;- filter(species1);

        <span class="hljs-comment">// As a side note, the new syntax for arguments maps is not only usable in action calls, but also in create, for instance</span>
        create species0 with: (location: { 100, 100 }, name: <span class="hljs-string">""</span>);
    }

    <span class="hljs-comment">// The ternary operator "(condition) ? statement_if_condition_true : statement_if_condition_false" can be used as follow :</span>
    int max (int i, int j) {
        return i &gt; j ? i : j;
    }

    list&lt;agent&gt; filter (container&lt;agent&gt; my_agents) {
        return my_agents where (each.location = <span class="hljs-literal">nil</span>);
    }

    <span class="hljs-comment">/**
      * USE OF OPERATORS 
      */</span>
    reflex operators {

    <span class="hljs-comment">// All the operators can now be written using a function-like form</span>
    <span class="hljs-comment">// It is true for unary operators (as before)</span>
        bool a &lt;- flip(0.4);
        <span class="hljs-comment">// .. but also for binary ones (in addition to the classic way)</span>
        int b &lt;- div(100, 23) + 100 div 23;
        geometry c1 &lt;- union(square(1), circle(10));
        <span class="hljs-comment">// The only exception to this rule is that of the built-in operators (like "and"/"or") and the ones whose names are not alphanumeric (like "+")</span>

        <span class="hljs-comment">// The big news is that operators are now allowed to be written using any number of parameters (not 1 or 2)</span>
        <span class="hljs-comment">// Here is an example with the "between" operator (written specially in Java to test this feature)</span>
        <span class="hljs-comment">// @operator(value = "between", can_be_const = true)</span>
        <span class="hljs-comment">// public static Boolean between(final Integer a, final Integer inf, final Integer sup) {</span>
        <span class="hljs-comment">//      if ( inf &gt; sup ) { return false; }</span>
        <span class="hljs-comment">//      return a &gt;= sup ? false : a &gt; inf; </span>
        <span class="hljs-comment">// }</span>
        bool e1 &lt;- between(5, 1, 10);
    }
    <span class="hljs-comment">/**
      * DEFINITION OF ASPECTS
      */</span>
    aspect default {
    <span class="hljs-comment">// draw now accepts any kind of arguments and decides what to do based on the type of the argument</span>
        draw circle(1);
        draw name;
        draw file(<span class="hljs-string">"image.jpg"</span>);

        <span class="hljs-comment">// special units (that take a value in the drawing scope) have been introduced to allow for a better control of the display</span>
        <span class="hljs-comment">// This statement will draw a circle of radius 10 pixels, whatever the level of zoom and size of the display</span>
        draw circle(10 °px);
        draw <span class="hljs-string">"Display dimensions: "</span> + °display_width + <span class="hljs-string">" "</span> + °display_height;
    }

}

<span class="hljs-comment">/** Species can "mirror" a list of agents (or another species). That is, their population is dynamically computed after the list or species mirrored.
* Their instances, which are actually "proxy" agents, possess an attribute called "target" that points towards the agent they mirror. Very useful for building graphs, for instance.
* The update of the population tries to preserve, as much as possible, the existing mapping (that is, proxy agents do not change targets if they do not die or disappear from the list) */</span>
species species0 {
    float speed &lt;- float(rnd(1000));
}

species species1 mirrors: species0 skills: [moving] {
    point location update: target.location + { 10, 10 };
    float speed1 update: self compute_speed_using_an_action (); <span class="hljs-comment">// No parameter as "max" is defaulted</span>
    float speed2 update: compute_speed_using_a_functional_attribute;
    float compute_speed_using_a_functional_attribute {
        speed of target
    }
    float compute_speed_using_an_action (int max &lt;- 100) {
        return min([max, int(speed of target)]);
    }

    init {
        <span class="hljs-statement">write</span> <span class="hljs-string">"I am "</span> + self.name + <span class="hljs-string">" and my target is "</span> + target.name;
    }

}

grid my_grid width: 100 height: 100 {
}

experiment exp1 type: gui {
    output {
        display Display type: opengl {
        <span class="hljs-comment">// Layers include a new keyword, "graphics", that allows to draw arbitrary shapes using the syntax found in the aspects of species</span>
        <span class="hljs-comment">// The same capability will be soon added to species/agents layers (in order to define on-the-fly aspects without changing the species itself)</span>
            graphics <span class="hljs-string">'G'</span> {
                draw sphere(10) at: { 50, 50 };
                if (true) {
                    draw <span class="hljs-string">"true"</span>;
                } else {
                    draw <span class="hljs-string">"false"</span>;
                }

            }

        }

    }

}
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/BC2019-Gama-Site/" class="nav-home"><img src="/BC2019-Gama-Site//img/gama-logo.png" alt="GAMA-Platform" width="66" height="58"/></a><div><h5>Networks</h5><a href="https://www.youtube.com/channel/UCWJ1kWGDDI-9u2f2uD0gcaQ" target="_blank"><i class="fab fa-youtube"></i> Youtube</a><a href="https://www.linkedin.com/company/gama-platform" target="_blank"><i class="fab fa-linkedin"></i> LinkedIn</a><a href="https://twitter.com/gamaplatform" target="_blank"><i class="fab fa-twitter"></i> Twitter</a><a href="https://www.facebook.com/GamaPlatform/" target="_blank"><i class="fab fa-facebook"></i> Facebook</a></div><div><h5>Mailing list</h5><a href="https://groups.google.com/forum/#!forum/gama-platform" target="_blank"><i class="fas fa-envelope"></i> For Users<br/>gama-platform@googlegroups.com</a><a href="https://groups.google.com/forum/#!forum/gama-dev" target="_blank"><i class="fas fa-envelope"></i> For Developers<br/>gama-dev@googlegroups.com</a></div><div><h5>Ecosystem</h5><a href="https://github.com/gama-platform/gama"><i class="fab fa-github"></i> GitHub Gama</a><a href="https://github.com/gama-platform/gama.experimental"><i class="fas fa-puzzle-piece"></i> Gama Experimental Plugins</a><a href="https://github.com/gama-platform/gama.models.experimental"><i class="fas fa-scroll"></i> Gama Experimental Models</a></div></section><section class="copyright">Copyright © 2019 GAMA-Platform</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0f9f28b9ab9efae89810921a351753b5',
                indexName: 'github',
                inputSelector: '#search_input_react'
              });
            </script></body></html>