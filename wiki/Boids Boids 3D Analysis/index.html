<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Boids 3D Analysis · GAMA-Platform</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="GAMA"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Boids 3D Analysis · GAMA-Platform"/><meta property="og:type" content="website"/><meta property="og:url" content="https://roiarthurb.github.io/BC2019-Gama-Site/"/><meta property="og:description" content="GAMA"/><meta property="og:image" content="https://roiarthurb.github.io/BC2019-Gama-Site//resources/images/general/GamaPlatform.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://roiarthurb.github.io/BC2019-Gama-Site//resources/images/general/GamaPlatform.png"/><link rel="shortcut icon" href="/BC2019-Gama-Site//img/gama-logo.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="/BC2019-Gama-Site//css/code-block-buttons.css"/><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js" async=""></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js" async=""></script><script type="text/javascript" src="/BC2019-Gama-Site/js/code-block-buttons.js" async=""></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.4.4/fuse.min.js" async=""></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><link rel="stylesheet" href="/BC2019-Gama-Site/css/main.css"/><script src="/BC2019-Gama-Site/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/BC2019-Gama-Site/"><img class="logo" src="/BC2019-Gama-Site//img/gama-logo_white.png" alt="GAMA-Platform"/><h2 class="headerTitleWithLogo">GAMA-Platform</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/BC2019-Gama-Site/wiki/Home" target="_self">Documentation</a></li><li class=""><a href="/BC2019-Gama-Site/wiki/Tutorials" target="_self">Tutorials</a></li><li class=""><a href="/BC2019-Gama-Site/help" target="_self">Download</a></li><li class=""><a href="/BC2019-Gama-Site/wiki/Contribute" target="_self">Contribute</a></li><li class=""><a target="_self"></a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Boids 3D Analysis</h1></header><article><div><span><p>_Author : _</p>
<p>This model shows the movement of boids following a goal, and creating without their own volonty, a flock . Four experiments are proposed : start is the 3D display of the boids like a real world, trajectory_analysis like the name means is about the analysis of the trajectory of the boids, Space Time Cube adds two display to see the movement of the boids using the time as the z-axis, and the last one represents the differents camera available in GAMA.</p>
<p>Code of the model :</p>
<pre><code class="hljs">model boids 

global torus: torus_environment{ 
    <span class="hljs-comment">//Number of boids to represent</span>
    int number_of_agents parameter: <span class="hljs-string">'Number of agents'</span> &lt;- 10 min: 1 max: 1000000;
    <span class="hljs-comment">//Number of obstacles to represent</span>
    int number_of_obstacles parameter: <span class="hljs-string">'Number of obstacles'</span> &lt;- 4 min: 0;
    <span class="hljs-comment">//Size of the boids</span>
    int boids_size parameter: <span class="hljs-string">'Boids size'</span> &lt;- 20 min: 1;
    <span class="hljs-comment">//Maximal speed allowed for the boids</span>
    float maximal_speed parameter: <span class="hljs-string">'Maximal speed'</span> &lt;- 15.0 min: 0.1 max: 15.0;
    <span class="hljs-comment">//Speed radius</span>
    float  radius_speed parameter: <span class="hljs-string">'radius speed'</span> &lt;- 0.5 min: 0.1;
    <span class="hljs-comment">//Cohesion factor of the boid group  in the range of a boid agent</span>
    int cohesion_factor parameter: <span class="hljs-string">'Cohesion Factor'</span> &lt;- 200;
    <span class="hljs-comment">//Alignment factor used for the boid group in the range of a boid agent</span>
    int alignment_factor parameter: <span class="hljs-string">'Alignment Factor'</span> &lt;- 100; 
    <span class="hljs-comment">//Minimal distance to move</span>
    float minimal_distance parameter: <span class="hljs-string">'Minimal Distance'</span> &lt;- 10.0; 
    <span class="hljs-comment">//Maximal turn done by the boids</span>
    int maximal_turn parameter: <span class="hljs-string">'Maximal Turn'</span> &lt;- 90 min: 0 max: 359; 
    
    <span class="hljs-comment">//Parameters of the environment and the simulations</span>
    int width_and_height_of_environment parameter: <span class="hljs-string">'Width/Height of the Environment'</span> &lt;- 800;  
    bool torus_environment parameter: <span class="hljs-string">'Toroidal Environment ?'</span> &lt;- false; 
    bool apply_cohesion &lt;- true parameter: <span class="hljs-string">'Apply Cohesion ?'</span>;
    bool apply_alignment &lt;- true parameter: <span class="hljs-string">'Apply Alignment ?'</span>;   
    bool apply_separation &lt;- true parameter: <span class="hljs-string">'Apply Separation ?'</span>;   
    bool apply_goal &lt;- true parameter: <span class="hljs-string">'Follow Goal ?'</span>; 
    bool apply_avoid &lt;- true parameter: <span class="hljs-string">'Apply Avoidance ?'</span>;   
    bool apply_wind &lt;- true parameter: <span class="hljs-string">'Apply Wind ?'</span>;     
    bool moving_obstacles &lt;- false parameter: <span class="hljs-string">'Moving Obstacles ?'</span>;    
    int bounds &lt;- int(width_and_height_of_environment / 20); 
    <span class="hljs-comment">//Wind vector </span>
    point wind_vector &lt;- {0,0} parameter: <span class="hljs-string">'Direction of the wind'</span>;  
    int goal_duration &lt;- 30 update: (goal_duration - 1); 
    <span class="hljs-comment">//Goal location</span>
    point goal &lt;- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 }; 
    list images of: image_file &lt;- [file(<span class="hljs-string">'../images/bird1.png'</span>),file(<span class="hljs-string">'../images/bird2.png'</span>),file(<span class="hljs-string">'../images/bird3.png'</span>)]; 
    string file_path_to_ocean &lt;- <span class="hljs-string">'../images/ocean.jpg'</span>;
    int xmin &lt;- bounds;    
    int ymin &lt;- bounds;  
    int xmax &lt;- (width_and_height_of_environment - bounds);    
    int ymax &lt;- (width_and_height_of_environment - bounds);   
    geometry shape &lt;- square(width_and_height_of_environment);


    <span class="hljs-comment">// flock's parameter </span>
    float two_boids_distance const: true init: 30.0;  
    int merging_distance const: true init: 30;
    bool create_flock  init: false;  
    
    init {
        <span class="hljs-comment">//Create the boids and place them randomlly</span>
        create boids number: number_of_agents { 
            location &lt;- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };
        } 
         
         <span class="hljs-comment">//Create an obstacle and place it randomly</span>
        create obstacle number: number_of_obstacles {
            location &lt;- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 }; 
        }
        <span class="hljs-comment">//Create a goal and place it at the goal location</span>
        create  boids_goal number: 1 {
            location &lt;- goal;
        }
        
        create aggregatedboids;
    }
    
    <span class="hljs-comment">//Reflex to create flock of boids considering the neighbors of each boids </span>
     reflex create_flocks {
        if create_flock {
            <span class="hljs-comment">//Create a map using a boid agent as a key and the list of all its neighbors as the value for the key</span>
            map&lt;boids, list&lt;boids&gt;&gt; potentialBoidsNeighborsMap;
            
            <span class="hljs-comment">//Search all the boids within the two boids distance from a boid agent and put them in the map</span>
            loop one_boids over: boids {
                list&lt;boids&gt; free_neighbors &lt;- boids overlapping (one_boids.shape + (two_boids_distance));
                remove one_boids from: free_neighbors;  

                if !(empty (free_neighbors)) {
                    add (one_boids::free_neighbors) to: potentialBoidsNeighborsMap;
                } 
            }
            
            <span class="hljs-comment">//Sorting of all the boids considered as key in the map by the length of their neighbors</span>
            list&lt;boids&gt; sorted_free_boids &lt;- (potentialBoidsNeighborsMap.keys) sort_by (length (potentialBoidsNeighborsMap at each));
            <span class="hljs-comment">//Removing of all the boids which has been considered as a key of the map, but  which are already included in a bigger list of neighbors by one of them neighbors</span>
            loop one_boids over: sorted_free_boids {
                list&lt;boids&gt; one_boids_neighbors &lt;- potentialBoidsNeighborsMap at one_boids;
                
                if  (one_boids_neighbors != <span class="hljs-literal">nil</span>) {
                    loop one_neighbor over: one_boids_neighbors {
                        remove one_neighbor from: potentialBoidsNeighborsMap; 
                    }
                }
            }
            <span class="hljs-comment">//Remove all the duplicates key of potentialBoidsNeighborsMap</span>
            list&lt;boids&gt; boids_neighbors &lt;- (potentialBoidsNeighborsMap.keys);
            loop one_key over: boids_neighbors {
                put (remove_duplicates (( potentialBoidsNeighborsMap at (one_key)) + one_key)) at: one_key in: potentialBoidsNeighborsMap;
            }
            
            <span class="hljs-comment">//Create a flock of boids considering the key of potentialBoidsNeighborsMap</span>
            loop one_key over: (potentialBoidsNeighborsMap.keys) {
                list&lt;boids&gt; micro_agents &lt;- potentialBoidsNeighborsMap at one_key;
                    
                if ( (length (micro_agents)) &gt; 1 ) {
                    create flock number: 1 with: [ color::rgb([rnd (255), rnd (255), rnd (255)]) ] { 
                        capture micro_agents as: boids_delegation;
                    }
                }
            } 
        }
    }  
}
<span class="hljs-comment">//Species boids_goal which represents the goal followed by the boids agent, using the skill moving</span>
species boids_goal skills: [moving] {
    float range const: true init: 20.0;
    int radius &lt;-3;
    
    <span class="hljs-comment">//Reflex to make the goal move in circle</span>
    reflex wander_in_circle{
        
        location &lt;- {world.shape.width/2 + world.shape.width/2 * cos (time*radius_speed), world.shape.width/2 + world.shape.width/2 * sin (time*radius_speed)};
        goal &lt;- location;
    }
    
    aspect default {
        draw circle(10) color: rgb (<span class="hljs-string">'red'</span>);
        draw circle(40) color: rgb (<span class="hljs-string">'orange'</span>) size: 40 empty: true;
    }
    
    aspect sphere{
        draw sphere(10) color: rgb(<span class="hljs-string">'white'</span>);
    }
} 

<span class="hljs-comment">//Species flock which represents the flock of boids agents, managing the boids agents captured</span>
species flock  
{
    <span class="hljs-comment">//Represent the cohesion index of the flock</span>
    float cohesionIndex &lt;- two_boids_distance update: (two_boids_distance + (length (members)));
    rgb color &lt;- rgb ([64, 64, 64]);
    geometry shape update: !(empty (members)) ? ( (polygon (members collect (boids_delegation (each)).location )) + 2.0 ) : ( polygon ([ {rnd (width_and_height_of_environment), rnd (width_and_height_of_environment)} ]) );
     
    <span class="hljs-comment">//Species that will represent the boids agents captured or inside a flock</span>
    species boids_delegation parent: boids topology: topology(world.shape)  
    {
        list&lt;boids&gt; others -&gt; {( (boids_delegation overlapping (shape + range))) - self};
 
        <span class="hljs-comment">//Action to compute the mass center of the flock</span>
        action compute_mass_center type: point 
        {
            loop o over: others 
            {
                if  dead(o) 
                {
                    do <span class="hljs-statement">write</span> <span class="hljs-facet">message</span>: <span class="hljs-string">'in '</span> + name + <span class="hljs-string">' agent with others contains death agents'</span>; 
                } 
            }
         
            return (length(others) &gt; 0) ? (mean (others collect (each.location)) ) : location;
        }

        reflex separation when: apply_separation {
        }
        
        reflex alignment when: apply_alignment {
        }
        <span class="hljs-comment">//Reflex to apply the cohesion on the boids agents</span>
        reflex cohesion when: apply_cohesion {
            point acc &lt;- (self compute_mass_center []) - location;
            acc &lt;- acc / cohesion_factor;
            velocity &lt;- velocity + acc;
        }
        
        reflex avoid when: apply_avoid {
        }       
    }
    <span class="hljs-comment">//Reflex to capture boids agents and release captured boids agents</span>
    reflex capture_release_boids {
         list&lt;boids_delegation&gt; removed_components &lt;- boids_delegation where ((each distance_to location) &gt; cohesionIndex );
         if !(empty (removed_components)) {
            release removed_components;
         }
         
         list&lt;boids&gt; added_components &lt;- boids where ((each distance_to location) &lt; cohesionIndex );
         if !(empty (added_components)) {
            capture added_components as: boids_delegation;
         }
    }
    <span class="hljs-comment">//Reflexe to kill the flock if the boids agents contained is lower than 2</span>
    reflex dispose when: ((length (members)) &lt; 2) {
         release members;
         do die;
    }
    <span class="hljs-comment">//Reflex to merge the flocks too close from each other</span>
    reflex merge_nearby_flocks {
        list&lt;flock&gt; nearby_flocks&lt;- (flock overlapping (shape +  merging_distance));
        if !(empty (nearby_flocks)) {
            nearby_flocks &lt;- nearby_flocks sort_by (length (each.members));
            flock largest_flock &lt;- nearby_flocks at ((length (nearby_flocks)) - 1);
             
            remove largest_flock from: nearby_flocks;
             
            list&lt;boids&gt; added_components ;
            loop one_flock over: nearby_flocks {
                release one_flock.members returns: released_boids; 
                
                loop rb over: released_boids {
                    add boids(rb) to: added_components;
                }
            }
            
            if !(empty (added_components)) { 
                ask largest_flock {
                    capture added_components as: boids_delegation;
                }
            } 
         }
    }
    
    aspect default {
        draw shape color: color;
    }
}
    
<span class="hljs-comment">//Species to represent the boids aggregated</span>
species aggregatedboids{
    reflex updateLocation{
      location &lt;- mean (boids collect (each.location)); 
    }
    aspect base{        
        draw sphere(10) color: rgb(<span class="hljs-string">'red'</span>);
    }
}
<span class="hljs-comment">//Species to represent the boids agent using the skill moving</span>
species boids skills: [moving] {
    <span class="hljs-comment">//Speed of the agent</span>
    float speed max: maximal_speed &lt;- maximal_speed;
    <span class="hljs-comment">//Range of movement for the neighbors</span>
    float range &lt;- minimal_distance * 2;
    <span class="hljs-comment">//Velocity of the agent</span>
    point velocity &lt;- {0,0};
    float hue &lt;- rnd(360) / 360;
    
    <span class="hljs-comment">//List of the neighbors boids</span>
    list&lt;boids&gt; others update: ((boids overlapping (circle (range)))  - self);
    
    <span class="hljs-comment">//Point of the mass center of the "flock" considered as the neighbors agents</span>
    point mass_center update:  (length(others) &gt; 0) ? (mean (others collect (each.location)) )  : location;
    
    <span class="hljs-comment">//Reflex to do the separation of the agents with the other boids in the minimal distance</span>
    reflex separation when: apply_separation {
        point acc &lt;- {0,0}; 
        loop boid over: (boids overlapping (circle(minimal_distance)))  {
            acc &lt;- acc - ((location of boid) - location);
        }  
        velocity &lt;- velocity + acc;
    }
    
    <span class="hljs-comment">//Reflex to do the alignement of the boids</span>
    reflex alignment when: apply_alignment {
        point acc &lt;- mean (others collect (each.velocity)) - velocity;
        velocity &lt;- velocity + (acc / alignment_factor);
    }
     
    <span class="hljs-comment">//Reflex to apply the cohesion using the mass center of the "flock"</span>
    reflex cohesion when: apply_cohesion {
        point acc &lt;- mass_center - location;
        acc &lt;- acc / cohesion_factor;
        velocity &lt;- velocity + acc; 
    }
    <span class="hljs-comment">//Reflex to avoid the obstacles</span>
    reflex avoid when: apply_avoid {
        point acc &lt;- {0,0};
        list&lt;obstacle&gt; nearby_obstacles &lt;- (obstacle overlapping (circle (range)) );
        loop obs over: nearby_obstacles {
            acc &lt;- acc - ((location of obs) - my (location));
        }
        velocity &lt;- velocity + acc; 
    }
    <span class="hljs-comment">//action to represent the bounding of the movement of the boids</span>
    action bounding {
        if  !(torus_environment) {
            if  (location.x) &lt; xmin {
                velocity &lt;- velocity + {bounds,0};
            } else if (location.x) &gt; xmax {
                velocity &lt;- velocity - {bounds,0};
            }
            
            if (location.y) &lt; ymin {
                velocity &lt;- velocity + {0,bounds};
            } else if (location.y) &gt; ymax {
                velocity &lt;- velocity - {0,bounds};
            }
            
        }
    }
    <span class="hljs-comment">//Reflex to follow the goal </span>
    reflex follow_goal when: apply_goal {
        velocity &lt;- velocity + ((goal - location) / cohesion_factor);
    }
    <span class="hljs-comment">//Reflex to apply the wind vector</span>
    reflex wind when: apply_wind {
        velocity &lt;- velocity + wind_vector;
    }
    <span class="hljs-comment">//action to move  </span>
    action do_move {  
        if (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {
            velocity &lt;- {(rnd(4)) -2, (rnd(4)) - 2}; 
        }
        point old_location &lt;- location; 
        do goto target: location + velocity;
        velocity &lt;- location - old_location; 
    }
    
    <span class="hljs-comment">//Reflex to do the movement, calling both bounding and do_move actions</span>
    reflex movement {
        do bounding;
        do do_move;
    }
    
    aspect basic{
        draw triangle(boids_size) color:rgb(<span class="hljs-string">'black'</span>);
    }
    aspect image {
        draw (images at (rnd(2))) size: boids_size rotate: heading color: rgb(<span class="hljs-string">'black'</span>) ;                
    }
            
    aspect dynamicColor{
        rgb cc &lt;- hsb (float(heading)/360.0,1.0,1.0);
        draw triangle(20) size: 15 rotate: 90 + heading color: cc border:cc depth:5;
        draw name;
    }
} 

<span class="hljs-comment">//Species which represents the obstacles using the skill moving</span>
species obstacle skills: [moving] {
    float speed &lt;- 0.1;  
    aspect default {
        draw triangle(20) color: rgb(<span class="hljs-string">'yellow'</span>) depth:5;
    }
}



experiment start type: gui {
    output {
        display RealBoids  type:opengl z_fighting:false {
            image <span class="hljs-string">'background'</span> file:file_path_to_ocean;
            species boids aspect: dynamicColor  position:{0,0,0.1} trace: 30;
            species boids_goal transparency:0.2 position:{0,0,0.1};
            species obstacle position:{0,0,0.1};        
        }
    }
}

experiment trajectory_analysis type: gui {
    output {
        
        display RealBoids  type:opengl {
            image <span class="hljs-string">'background'</span> file:file_path_to_ocean;
            species boids aspect: dynamicColor transparency:0.5 position:{0,0,0.1};
            species boids aspect: image transparency:0.5 position:{0,0,0.11};
            species boids_goal transparency:0.2 position:{0,0,0.1};
            species obstacle position:{0,0,0.1};        
        }
                
        display AggregatedBoidsTrajectory  type:opengl  {
            image <span class="hljs-string">'background'</span> file:file_path_to_ocean;
            species aggregatedboids  aspect: base trace:100 fading: true ;
            species boids_goal aspect:sphere;       
        }
    } 
}

experiment SpaceTimeCube type: gui {
    output {
        display RealBoids  type:opengl {
            image <span class="hljs-string">'background'</span> file:file_path_to_ocean;
            species boids aspect: dynamicColor transparency:0.5 position:{0,0,0.1};
            species boids aspect: image transparency:0.5 position:{0,0,0.11};
            species boids_goal transparency:0.2 position:{0,0,0.1};
            species obstacle position:{0,0,0.1};        
        }
        
        display SpaceTimeCubeAll  type:opengl {
            image <span class="hljs-string">'background'</span> file:file_path_to_ocean;
            species boids trace:true{
                draw triangle(20) size: 15 rotate: 90 + heading color: hsb (float(heading)/360.0,1.0,1.0) border:hsb (float(heading)/360.0,1.0,1.0) depth:5 at: {location.x ,location.y,location.z+time};   
            }
            species boids_goal trace:true{
                draw sphere(10) color: rgb(<span class="hljs-string">'yellow'</span>) at: {location.x ,location.y,location.z+time};
            }   
        }
                
        display SpaceTimeCubeAggregated  type:opengl {
            image <span class="hljs-string">'background'</span> file:file_path_to_ocean;
            species aggregatedboids trace:true{
                draw sphere(10) color: rgb(<span class="hljs-string">'red'</span>) at: {location.x ,location.y,location.z+time}; 
            }
            species boids_goal trace:true{
                draw sphere(10) color: rgb(<span class="hljs-string">'yellow'</span>) at: {location.x ,location.y,location.z+time};
            }   
        }
    }
}

experiment MultipleView type: gui {
    output {


        display RealBoids   type:opengl {
            image <span class="hljs-string">'background'</span> file:file_path_to_ocean;
            species boids aspect: image  transparency:0.5 position:{0,0,0.25};
            species boids_goal transparency:0.2 position:{0,0,0.25};
            species obstacle ;
            species boids  aspect: dynamicColor transparency:0.2 position:{0,0,0.24};       
        }
        
        display ThirdPersonn  type:opengl camera_interaction:false camera_pos:{int(first(boids).location.x),int(first(boids).location.y),250} 
        camera_look_pos:{int(first(boids).location.x),first(boids).location.y,0} 
        camera_up_vector:{0.0,-1.0,0.0} {
        
            image <span class="hljs-string">'background'</span> file:file_path_to_ocean;
            species obstacle;
            species boids  aspect: dynamicColor transparency:0.2 ;
            species boids_goal  transparency:0.2;       
        }
        
            
        display FirstPerson  type:opengl camera_interaction:false camera_pos:{int(first(boids).location.x),int(first(boids).location.y),10} 
            camera_look_pos:{cos(first(boids).heading)*first(boids).speed+int(first(boids).location.x),
            sin(first(boids).heading)*first(boids).speed+int(first(boids).location.y),10} 
            camera_up_vector:{0.0,0.0,1.0} {    
            image <span class="hljs-string">'background'</span> file:file_path_to_ocean;
            species obstacle ;
            species boids  aspect: dynamicColor transparency:0.2 ;
            species boids_goal  transparency:0.2;       
        }
    }
}
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/BC2019-Gama-Site/" class="nav-home"><img src="/BC2019-Gama-Site//img/gama-logo.png" alt="GAMA-Platform" width="66" height="58"/></a><div><h5>Networks</h5><a href="https://www.youtube.com/channel/UCWJ1kWGDDI-9u2f2uD0gcaQ" target="_blank"><i class="fab fa-youtube"></i> Youtube</a><a href="https://www.linkedin.com/company/gama-platform" target="_blank"><i class="fab fa-linkedin"></i> LinkedIn</a><a href="https://twitter.com/gamaplatform" target="_blank"><i class="fab fa-twitter"></i> Twitter</a><a href="https://www.facebook.com/GamaPlatform/" target="_blank"><i class="fab fa-facebook"></i> Facebook</a></div><div><h5>Mailing list</h5><a href="https://groups.google.com/forum/#!forum/gama-platform" target="_blank"><i class="fas fa-envelope"></i> For Users<br/>gama-platform@googlegroups.com</a><a href="https://groups.google.com/forum/#!forum/gama-dev" target="_blank"><i class="fas fa-envelope"></i> For Developers<br/>gama-dev@googlegroups.com</a></div><div><h5>Ecosystem</h5><a href="https://github.com/gama-platform/gama"><i class="fab fa-github"></i> GitHub Gama</a><a href="https://github.com/gama-platform/gama.experimental"><i class="fas fa-puzzle-piece"></i> Gama Experimental Plugins</a><a href="https://github.com/gama-platform/gama.models.experimental"><i class="fas fa-scroll"></i> Gama Experimental Models</a></div></section><section class="copyright">Copyright © 2019 GAMA-Platform</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0f9f28b9ab9efae89810921a351753b5',
                indexName: 'github',
                inputSelector: '#search_input_react'
              });
            </script></body></html>